<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenRTM: RTC::CorbaPort Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceRTC.html">RTC</a>::<a class="el" href="classRTC_1_1CorbaPort.html">CorbaPort</a>
  </div>
</div>
<div class="contents">
<h1>RTC::CorbaPort Class Reference</h1><!-- doxytag: class="RTC::CorbaPort" --><!-- doxytag: inherits="RTC::PortBase" -->
<p>RT Conponent CORBA service/consumer Port.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CorbaPort_8h_source.html">CorbaPort.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTC::CorbaPort:</div>
<div class="dynsection">
 <div class="center">
  <img src="classRTC_1_1CorbaPort.png" usemap="#RTC::CorbaPort_map" alt=""/>
  <map id="RTC::CorbaPort_map" name="RTC::CorbaPort_map">
<area href="classRTC_1_1PortBase.html" alt="RTC::PortBase" shape="rect" coords="0,0,100,24"/>
</map>
 </div>
</div>

<p><a href="classRTC_1_1CorbaPort-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>CorbaConsumerHolder</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The structure to be stored <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> information. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>CorbaProviderHolder</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The structure to be stored Provider information. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>unsubscribe</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor to release Consumer's object. <br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1CorbaPort.html#a2bbb2b39d9df5f82c61315fe3fa5cf7a">CorbaPort</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a2bbb2b39d9df5f82c61315fe3fa5cf7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1CorbaPort.html#a7aa53f50989ea68ca419b9f6d5a8cfcc">~CorbaPort</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor.  <a href="#a7aa53f50989ea68ca419b9f6d5a8cfcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1CorbaPort.html#a5e62ee7818cafc02a3e7002a3742daab">init</a> (<a class="el" href="classcoil_1_1Properties.html">coil::Properties</a> &amp;prop)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializing properties.  <a href="#a5e62ee7818cafc02a3e7002a3742daab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1CorbaPort.html#af9de5f6a90d3b0f6bfc07317e6a0d44f">registerProvider</a> (const char *instance_name, const char *type_name, PortableServer::RefCountServantBase &amp;provider)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register the provider.  <a href="#af9de5f6a90d3b0f6bfc07317e6a0d44f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1CorbaPort.html#a70d4b49921c82916181aa681eea2ab2b">registerConsumer</a> (const char *instance_name, const char *type_name, <a class="el" href="classRTC_1_1CorbaConsumerBase.html">CorbaConsumerBase</a> &amp;consumer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register the consumer.  <a href="#a70d4b49921c82916181aa681eea2ab2b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1CorbaPort.html#a71aa316c3324369c4462193d10a5d098">publishInterfaces</a> (ConnectorProfile &amp;connector_profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish information about interfaces.  <a href="#a71aa316c3324369c4462193d10a5d098"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1CorbaPort.html#ad9a122cbe2f9892cc9555e805571742e">subscribeInterfaces</a> (const ConnectorProfile &amp;connector_profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subscribe to interface.  <a href="#ad9a122cbe2f9892cc9555e805571742e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1CorbaPort.html#a4776e122a3066d9e3a3e5d1e5da45b98">unsubscribeInterfaces</a> (const ConnectorProfile &amp;connector_profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsubscribe interfaces.  <a href="#a4776e122a3066d9e3a3e5d1e5da45b98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1CorbaPort.html#a1b9efe804a293b2c38a9cbe3b5ba54a0">activateInterfaces</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activate all Port interfaces.  <a href="#a1b9efe804a293b2c38a9cbe3b5ba54a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1CorbaPort.html#a4c25f8e04aa9cceff24c31ea3fec4e5b">deactivateInterfaces</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deactivate all Port interfaces.  <a href="#a4c25f8e04aa9cceff24c31ea3fec4e5b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoil_1_1Properties.html">coil::Properties</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1CorbaPort.html#afb24858ffd644ff6d52bb422cfb442da">m_properties</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Properties.  <a href="#afb24858ffd644ff6d52bb422cfb442da"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>RT Conponent CORBA service/consumer Port. </p>
<p><a class="el" href="classRTC_1_1CorbaPort.html" title="RT Conponent CORBA service/consumer Port.">CorbaPort</a> is an implementation of the Port of RT-Component's that provides user-defined CORBA Object Service and <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a>. </p>
<p>RT-Component can provide user-defined CORBA serivces, which is called RT-Serivce (Provider), through the Ports. RT-Component can also provide place-holder, which is called RT-Serivce <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a>, to use other RT-Component's service. </p>
<p>The <a class="el" href="classRTC_1_1CorbaPort.html" title="RT Conponent CORBA service/consumer Port.">CorbaPort</a> can manage any number of Providers and Consumers, can associate Consumers with correspondent Providers when establishing connection among Ports. </p>
<p>Usually, <a class="el" href="classRTC_1_1CorbaPort.html" title="RT Conponent CORBA service/consumer Port.">CorbaPort</a> is used like the following.</p>
<pre>
 <a class="el" href="classRTC_1_1CorbaPort.html" title="RT Conponent CORBA service/consumer Port.">RTC::CorbaPort</a> m_port0; // declaration of Port</pre><pre> MyService_impl m_mysvc0; // Serivce Provider that is provided by the Port
 RTC::CorbaConsumer&lt;YourService&gt; m_cons0; // <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> of the Port</pre><pre> // register Service Provider to the Port
 m_port0.registerProvider("MyService0", "Generic", m_mysvc0);
 // register Service <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> to the Port
 m_port0.registerConsumer("YourService0", "Generic", m_cons0 );</pre><pre> // after connect established</pre><pre> m_cons0-&gt;your_service_function(); // call a YourService's function</pre><pre> // in another component that is connected with the Port
 m_cons1-&gt;my_service_function(); // call a MyService's function
 </pre><p>Registering Service Provider by <a class="el" href="classRTC_1_1CorbaPort.html#af9de5f6a90d3b0f6bfc07317e6a0d44f" title="Register the provider.">registerProvider()</a>, it can be used from other RT-Components. Registering Service <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> by <a class="el" href="classRTC_1_1CorbaPort.html#a70d4b49921c82916181aa681eea2ab2b" title="Register the consumer.">registerConsumer()</a>, other RT-Component's services can be used through the consumer object.</p>
<p>PortInterfaceProfile is a one of the profile information to store Provider interface and <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> interface information. Tools or other RTCs should call one of the Port::connect() with an appropriate ConnectorProfile.</p>
<p>In addition, the instance name "*" declares a special type of instance.</p>
<p>When the name of the PROVIDED type interface that is the provider interface is "*", Provider interface's instance does not exist at the beginning of connection sequence. The instances will be created dynamically according to the consumer interface requirement at the connection sequence. Although the instance name does not exist at the beginning of connection sequence, the created providers shall publish its references to the ConnectorProfile with interface descriptor adequately in the interface publisher phase of the connection sequence.</p>
<p>If REQUIRED interface name that is <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> interface name is "*", it shows that one <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> interface is able to connect with multiple Provider interfaces. (This feature is not implemented.)</p>
<p>The following describes the rules that specify interface connection between ports.</p>
<p>The descriptor format of interfaces associated with Ports is declared as follows. Now some of interface properties are assumed as the followings.</p>
<ul>
<li><a class="el" href="namespaceRTC.html" title="RT-Component.">RTC</a> instance name: rtc_iname</li>
<li>Port name: port_name</li>
<li>Interface polarity: if_polarity</li>
<li>Interface type name: if_tname</li>
<li>INterface instance name: if_iname</li>
</ul>
<p>The interface descriptors shall be declared as follows.</p>
<p>&lt;rtc_iname&gt;.port.&lt;port_name&gt;.&lt;if_polarity&gt;.&lt;if_tname&gt;.&lt;if_iname&gt;</p>
<p>When PROVIDED that is Provider interface properties are the followings,</p>
<ul>
<li>rtc_iname = MyComp0</li>
<li>port_name = myservice</li>
<li>if_polarity = provided</li>
<li>if_tname = echo_interface</li>
<li>if_iname = echo_interface2 the interface descriptor is here.</li>
</ul>
<p>MyComp0.port.myservice.provided.echo_interface.echo_interface2</p>
<p>And, when REQUIRED that is <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> interfaces properties are the followings,</p>
<ul>
<li>rtc_iname = YourComp0</li>
<li>port_name = yourservice</li>
<li>if_polarity = required</li>
<li>if_tname = hoge_interface</li>
<li>if_iname = hoge_interface1</li>
</ul>
<p>interface descriptor is as follows.</p>
<p>YourComp0.port.myservice.required.hoge_interface.hoge_inteface1</p>
<p>Specific instance name descriptors that are dynamically generated at the connection time are defined here.</p>
<ul>
<li>&lt;type_name&gt;*: "Dynamically generated" instance descriptor.</li>
<li>&lt;type_name&gt;+: "Incrementally generated" instance descriptor.</li>
</ul>
<p>When the "Dynamically generated" instance descriptor: "&lt;type_name&gt;*" is specified as interface descriptor that is required by consumers, the provider will generate a instance. If n consumers who demand a provider by the "&lt;type_name&gt;" descriptor exist, the following relation which processes the call from these consumers by one provider will be established.</p>
<pre>
 consumer0 ]---&lt;
 consumer1 ]---&lt;  O----[ provider0
 consumer2 ]---&lt;
 </pre><p>On the other hand, when incremental generated type instance name descriptor "&lt;type_name&gt;+" is specified as the provider interface descriptor whom consumers demand, provider's instances are dynamically generated for the number of the descriptors "&lt;type_name&gt;+". When n consumers who demand a provider by the descriptor "&lt;type_name&gt;+" exist the following relations in which n providers process each call from the consumers will be established.</p>
<pre>
 consumer0 ]---&lt;  O----[ provider0
 consumer1 ]---&lt;  O----[ provider1
 consumer2 ]---&lt;  O----[ provider2
 </pre><p>Describing the appropriate interface mapping specification in the ConnectorProfile::properties, selective connections between providers/consumers interface can be established at the time of connection. However, when different <a class="el" href="namespaceRTC.html" title="RT-Component.">RTC</a> instances of the same instance name exist in a connection, since an interface descriptor uniqueness cannot be guaranteed, this connection mapping rules cannot be used.</p>
<p>Here, assume that an interface descriptor is given as &lt;if_desc0&gt;, &lt;if_desc1&gt;, .... And assume that the key and the value of NVList in ConnectorProfile::properties are given as "key: value".</p>
<p>Now the case where the service ports of two components are connected is considered. When the service port of each component is the following,</p>
<ul>
<li>rtc_iname: MyComp0 <br/>
 port_name: mycomp_service <br/>
 interfaces:<ul>
<li>if_polarity: provided <br/>
 if_iname: echo0 <br/>
 if_tname: Echo</li>
<li>if_polarity: required <br/>
 if_iname: add0 <br/>
 if_tname: add</li>
</ul>
</li>
</ul>
<ul>
<li>rtc_iname: YourComp0 <br/>
 port_name: yourcomp_service <br/>
 interfaces:<ul>
<li>if_polarity: required <br/>
 if_iname: echo9 <br/>
 if_tname: Echo</li>
<li>if_polarity: provided <br/>
 if_iname: add9 <br/>
 if_tname: add</li>
</ul>
</li>
</ul>
<pre>
      MyComp0                                 YourComp0
     _______ mycomp_service   yourcomp_service ______
            |                                 |
          |~~~|---O echo0         echo9 &gt;---|~~~|
          |   |---&lt; add0          add9  O---|   |
           ~T~                               ~T~
            |                                 |
 </pre><p>Assume that connection between echo0 (provider) of MyComp0 component and echo9 (consumer) of YourComp0 component, and add0 (consumer) of MyComp0 and add0 (provider) of YourComp0 is established. In this case, ConnectorProfile is set up as follows.</p>
<pre>
 ConnectorProfile:
   name: any connector name
   connector_id: empty string
   ports[]: mycomp_service's reference, yourcomp_service's reference
   properties:
     &lt;add0&gt;: &lt;add9&gt;
     &lt;echo9&gt;: &lt;echo0&gt;
 </pre><p>Please note that &lt;add0&gt;, &lt;add9&gt;, &lt;echo0&gt; and &lt;echo9&gt; are the following.</p>
<pre>
 &lt;add0&gt; is MyComp0.port.mycomp_service.required.add.add0
 &lt;add9&gt; is YourComp0.port.yourcomp_service.provided.add.add9
 &lt;echo0&gt; is MyComp0.port.mycomp_service.provided.echo.echo0
 &lt;echo9&gt; is YourComp0.port.yourcomp_service.required.echo.echo9
 </pre><p>In the connection process, the provider and the consumer of each port carries out the following process respectively in the virtual functions such as <a class="el" href="classRTC_1_1CorbaPort.html#a71aa316c3324369c4462193d10a5d098" title="Publish information about interfaces.">CorbaPort::publishInterfaces()</a> and CorbaPort::subscribeInerfaces().</p>
<p>A provider sets its IOR string as a value and its interface descriptor as a key in the ConnectorProfile::properties in a <a class="el" href="classRTC_1_1CorbaPort.html#a71aa316c3324369c4462193d10a5d098" title="Publish information about interfaces.">publishInterfaces()</a> function. Since this interface descriptor's uniqueness is guaranteed in the current connector, the key of NameValue in the ConnectorProfile::properties is unique.</p>
<p>[This functionalities are not implemented] The dynamically generated provider is processed according to the following procedure. The publishInterface() function scans dynamic instance descriptors such as "&lt;type_name&gt;*" and "&lt;type_name&gt;+" in the ConnectorProfile::properties. When the dynamic generation instance descriptor "&lt;tupe_name&gt;*" exists, one instance of provider is generated, and its descriptor and its IOR string are set to ConnectorProfile::properties as the key and the value respectively. Simultaneously, in the ConnectorProfile::properties, all the instance descriptor with the dynamic generation instance name "&lt;type_name&gt;*" will be replaced with newly generated instance descriptor.</p>
<p>When the incremental dynamic generation instance descriptor exists, providers are generated for the number of the descriptors, and its descriptor and its IOR string are set to ConnectorProfile::properties as the key and the value respectively. Simultaneously, in the ConnectorProfile::properties, all the instance descriptor with the dynamic generation instance name "&lt;type_name&gt;+" will be replaced with newly generated instance descriptor.</p>
<p>The providers do not perform particular operation in <a class="el" href="classRTC_1_1CorbaPort.html#ad9a122cbe2f9892cc9555e805571742e" title="Subscribe to interface.">subscribeInterfaces()</a> function.</p>
<p>The consumers do not perform particular operation in publisherInterfaces() function.</p>
<p>On the other hand, a consumer searches a key-value pair with the key of consumer interface descriptor, and if the pair exists, it obtains provider's descriptor from the value. The consumer searches again a key-value pair with the key of provider interface descriptor, and it obtains provider's reference and the reference is set as the consumer's service object. In addition, reserved string "nil" or "null" are used not to set specific provider.</p>
<p>If consumer's interface descriptors does not exists in the ConnectorProfile::properties, the consumer searches a provider with same type name and instance name, and its reference is set to the consumer. This rule is for only backward compatibility, and it is not recommended from version 1.0.</p>
<p>The correspondence of a provider versus a consumer does not need to be one to one, and the case of one provider to n-consumers and the case of m-providers to one consumer are allowed. The one provider to n-consumers case can be realized by the above mentioned methods. The one consumer to m-provider case can be specified to set the consumer descriptor and comma-separated provider descriptors into the key and the value respectively.</p>
<p>The following option is available to specify the strictness of interfaces connection.</p>
<p>port.connection.strictness: strict, best_effort</p>
<p>strict: The connection is established, if only all the specified consumers are set appropriate references and narrowed successfully.</p>
<p>best_effort: The connection is established without any errors, even if appropriate reference does not exist or reference narrowing fails.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>0.4.0 </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2bbb2b39d9df5f82c61315fe3fa5cf7a"></a><!-- doxytag: member="RTC::CorbaPort::CorbaPort" ref="a2bbb2b39d9df5f82c61315fe3fa5cf7a" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTC::CorbaPort::CorbaPort </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>In the ctor, a given name is set into <a class="el" href="classRTC_1_1PortBase.html" title="Port base class.">PortBase</a>, and the following property is added to the PortProfile::properties,</p>
<ul>
<li>port.port_type: "CorbaPort"</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of Port </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7aa53f50989ea68ca419b9f6d5a8cfcc"></a><!-- doxytag: member="RTC::CorbaPort::~CorbaPort" ref="a7aa53f50989ea68ca419b9f6d5a8cfcc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual RTC::CorbaPort::~CorbaPort </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Virtual destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1b9efe804a293b2c38a9cbe3b5ba54a0"></a><!-- doxytag: member="RTC::CorbaPort::activateInterfaces" ref="a1b9efe804a293b2c38a9cbe3b5ba54a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTC::CorbaPort::activateInterfaces </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activate all Port interfaces. </p>
<p>This operation activate all interfaces that is registered in the ports. </p>

<p>Implements <a class="el" href="classRTC_1_1PortBase.html#ad779347bae007555968dda9e78004e34">RTC::PortBase</a>.</p>

</div>
</div>
<a class="anchor" id="a4c25f8e04aa9cceff24c31ea3fec4e5b"></a><!-- doxytag: member="RTC::CorbaPort::deactivateInterfaces" ref="a4c25f8e04aa9cceff24c31ea3fec4e5b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTC::CorbaPort::deactivateInterfaces </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deactivate all Port interfaces. </p>
<p>This operation deactivate all interfaces that is registered in the ports. </p>

<p>Implements <a class="el" href="classRTC_1_1PortBase.html#a8dfb8a33b92b9fc9b6c070df2def633f">RTC::PortBase</a>.</p>

</div>
</div>
<a class="anchor" id="a5e62ee7818cafc02a3e7002a3742daab"></a><!-- doxytag: member="RTC::CorbaPort::init" ref="a5e62ee7818cafc02a3e7002a3742daab" args="(coil::Properties &amp;prop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::CorbaPort::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoil_1_1Properties.html">coil::Properties</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prop</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializing properties. </p>
<p>This operation initializes outport's properties. If a property "connection_limit" is set and appropriate value is set to this property value, the number of maximum connection is set as this value. If the property does not exist or invalid value is set to this property, the maximum number of connection will be set unlimited.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prop</em>&nbsp;</td><td>properties of the <a class="el" href="classRTC_1_1CorbaPort.html" title="RT Conponent CORBA service/consumer Port.">CorbaPort</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71aa316c3324369c4462193d10a5d098"></a><!-- doxytag: member="RTC::CorbaPort::publishInterfaces" ref="a71aa316c3324369c4462193d10a5d098" args="(ConnectorProfile &amp;connector_profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::CorbaPort::publishInterfaces </td>
          <td>(</td>
          <td class="paramtype">ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Publish information about interfaces. </p>
<p>This operation publishes Provider interfaces information, which is owned by this port, to the other Ports via ConnectorProfile::properties. Now it is assumed <a class="el" href="namespaceRTC.html" title="RT-Component.">RTC</a> instance name and other information is as follows,</p>
<ul>
<li><a class="el" href="namespaceRTC.html" title="RT-Component.">RTC</a> instance name: rtc_iname</li>
<li>Port name: port_name</li>
<li>Interface polarity: if_polarity</li>
<li>Interface type name: if_tname</li>
<li>Interface instance name: if_iname</li>
</ul>
<p>the following values are stored as the "name" and the "value" of the NameValue typee element in ConnectorProfile::properties.</p>
<ul>
<li>name &lt;rtc_iname&gt;.port.&lt;port_name&gt;.provided.&lt;if_tname&gt;.&lt;if_iname&gt;</li>
<li>value IOR string value of interface reference</li>
</ul>
<p>In addition, although the following NameValue values are also stored for the backward compatibility, this will be deleted in the future version.</p>
<ul>
<li>name port.&lt;if_tname&gt;.&lt;if_iname&gt;</li>
<li>value IOR string value of interface reference</li>
</ul>
<p>These values are stored in the ConnectorProfile::properties and are propagated to the other Ports. If the <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> interface exists that requires this Provider interface, it will retrieve reference from the ConnectorProfile and utilize it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>Connector profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return code of ReturnCode_t type </dd></dl>

<p>Implements <a class="el" href="classRTC_1_1PortBase.html#acf31878c5912f56c122aaa2310e182de">RTC::PortBase</a>.</p>

</div>
</div>
<a class="anchor" id="a70d4b49921c82916181aa681eea2ab2b"></a><!-- doxytag: member="RTC::CorbaPort::registerConsumer" ref="a70d4b49921c82916181aa681eea2ab2b" args="(const char *instance_name, const char *type_name, CorbaConsumerBase &amp;consumer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTC::CorbaPort::registerConsumer </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>instance_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTC_1_1CorbaConsumerBase.html">CorbaConsumerBase</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>consumer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register the consumer. </p>
<p>This operation registers a consumer, which is a service placeholder this port requires. These are associated internally with specified instance_name, type_name and <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> itself to the argument as service's instance name and its type name associated with <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a>. The service Provider interface' references will be set automatically to the <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> Interface object when connections are established, according to the rules that are described at the subscribeInterface() function's documentation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instance_name</em>&nbsp;</td><td>Instance name of the service <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> requires </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type_name</em>&nbsp;</td><td>Type name of the service <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> requires </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>consumer</em>&nbsp;</td><td>CORBA service consumer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>False would be returned if the same instance_name was registered </dd></dl>

</div>
</div>
<a class="anchor" id="af9de5f6a90d3b0f6bfc07317e6a0d44f"></a><!-- doxytag: member="RTC::CorbaPort::registerProvider" ref="af9de5f6a90d3b0f6bfc07317e6a0d44f" args="(const char *instance_name, const char *type_name, PortableServer::RefCountServantBase &amp;provider)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTC::CorbaPort::registerProvider </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>instance_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PortableServer::RefCountServantBase &amp;&nbsp;</td>
          <td class="paramname"> <em>provider</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register the provider. </p>
<p>This operation registers a servant, which is provided in this Port, to the Port. The servant is associated with "instance_name" and "type_name" as the instance name of the servant and as the type name of the servant. A given servant will be stored in the <a class="el" href="classRTC_1_1CorbaPort.html" title="RT Conponent CORBA service/consumer Port.">CorbaPort</a>, and this is registered as RTC::PROVIDED interface into the PortInterfaceProfile.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>instance_name</em>&nbsp;</td><td>Instance name of servant </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type_name</em>&nbsp;</td><td>Type name of the servant </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>provider</em>&nbsp;</td><td>CORBA servant</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return false if the same name of instance_name is already registered. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9a122cbe2f9892cc9555e805571742e"></a><!-- doxytag: member="RTC::CorbaPort::subscribeInterfaces" ref="ad9a122cbe2f9892cc9555e805571742e" args="(const ConnectorProfile &amp;connector_profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::CorbaPort::subscribeInterfaces </td>
          <td>(</td>
          <td class="paramtype">const ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subscribe to interface. </p>
<p>Retrieve information associated with Provider matches <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> owned by this port and set the object reference to <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a>.</p>
<p>Now, <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> is registered as the following: </p>
<pre>
  PortInterfaceProfile
  {
    instance_name = "PA10_0";
    type_name     = "Manipulator";
    polarity      = REQUIRED;
  }
 </pre><p> Find the object reference of Serivce Provider that is registered as the following of other ports: </p>
<pre>
  PortInterfaceProfile
  {
    instance_name = "PA10_0";
    type_name     = "Manipulator";
    polarity      = PROVIDED;
  }
 </pre><p> and set to <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a>. In fact, find NameValue that is registered as the following to ConnectorProfile::properties: </p>
<pre>
 NameValue = { "port.Manipulator.PA10_0": &lt;Object reference&gt;=""&gt; }
 </pre><p> and set the object reference to <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>Connector profile</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return code of ReturnCode_t type </dd></dl>

<p>Implements <a class="el" href="classRTC_1_1PortBase.html#afce755069836c1ee637784e2a9e5a02b">RTC::PortBase</a>.</p>

</div>
</div>
<a class="anchor" id="a4776e122a3066d9e3a3e5d1e5da45b98"></a><!-- doxytag: member="RTC::CorbaPort::unsubscribeInterfaces" ref="a4776e122a3066d9e3a3e5d1e5da45b98" args="(const ConnectorProfile &amp;connector_profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTC::CorbaPort::unsubscribeInterfaces </td>
          <td>(</td>
          <td class="paramtype">const ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unsubscribe interfaces. </p>
<p>Release all Objects that was set in <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> associated with the given ConnectorProfile.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>Connector profile </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRTC_1_1PortBase.html#a8a843a387e99d4d4daa6e829eb1db569">RTC::PortBase</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="afb24858ffd644ff6d52bb422cfb442da"></a><!-- doxytag: member="RTC::CorbaPort::m_properties" ref="afb24858ffd644ff6d52bb422cfb442da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoil_1_1Properties.html">coil::Properties</a> <a class="el" href="classRTC_1_1CorbaPort.html#afb24858ffd644ff6d52bb422cfb442da">RTC::CorbaPort::m_properties</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Properties. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu May 24 23:25:22 2012 for OpenRTM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
