<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenRTM: coil::Properties Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacecoil.html">coil</a>::<a class="el" href="classcoil_1_1Properties.html">Properties</a>
  </div>
</div>
<div class="contents">
<h1>coil::Properties Class Reference</h1><!-- doxytag: class="coil::Properties" -->
<p>Class represents a set of properties.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Properties_8h_source.html">Properties.h</a>&gt;</code></p>

<p><a href="classcoil_1_1Properties-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#ac450ea6ec45f1166cc630bbc26535a00">Properties</a> (const char *key=&quot;&quot;, const char *value=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor(Create only root node).  <a href="#ac450ea6ec45f1166cc630bbc26535a00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a220dd189b126cb4faeea1c6849512667">Properties</a> (std::map&lt; std::string, std::string &gt; &amp;defaults)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor(Give the default value with map).  <a href="#a220dd189b126cb4faeea1c6849512667"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#ae93d761ca0f93dfe41be33b67a2b2741">Properties</a> (const char *defaults[], long num=LONG_MAX)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor(Give the default value with char*[]).  <a href="#ae93d761ca0f93dfe41be33b67a2b2741"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#aebf43709176e3a922290bd762544ce41">Properties</a> (const <a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;prop)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy Constructor.  <a href="#aebf43709176e3a922290bd762544ce41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#acf1a3c8e401765c285e318d6863a6e77">operator=</a> (const <a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;prop)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#acf1a3c8e401765c285e318d6863a6e77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a1edb4ee99d0a187307687bf7472efe3d">~Properties</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a1edb4ee99d0a187307687bf7472efe3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a3809685330fc7d8ced176e8dbe8dd2f7">getName</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get Names.  <a href="#a3809685330fc7d8ced176e8dbe8dd2f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#aa402bd7d600a60560782622ef7ece205">getValue</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get values.  <a href="#aa402bd7d600a60560782622ef7ece205"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a78d23bd777bb462168a1807750267d6d">getDefaultValue</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get default values.  <a href="#a78d23bd777bb462168a1807750267d6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classcoil_1_1Properties.html">Properties</a> * &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a51cdcfada7734595f8a58beaa4356c72">getLeaf</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get elements of leaf.  <a href="#a51cdcfada7734595f8a58beaa4356c72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcoil_1_1Properties.html">Properties</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a930c4db15600de4f49370741652221cf">getRoot</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get root element.  <a href="#a930c4db15600de4f49370741652221cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a91ad72f8d7c41624e2258c5a9331bd2a">getProperty</a> (const std::string &amp;key) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for the property with the specified key in this property.  <a href="#a91ad72f8d7c41624e2258c5a9331bd2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#ac79dfbccc6050fcf4631063d1090af87">getProperty</a> (const std::string &amp;key, const std::string &amp;def) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for the property with the specified key in property list.  <a href="#ac79dfbccc6050fcf4631063d1090af87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a184d704a37d9eb2052b77a0624060b34">operator[]</a> (const std::string &amp;key) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for the property with the specified key in property list.  <a href="#a184d704a37d9eb2052b77a0624060b34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a2c241eddb268f07442e1d008154b2fef">operator[]</a> (const std::string &amp;key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for the property with the specified key in property list.  <a href="#a2c241eddb268f07442e1d008154b2fef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a9536505f283c0fc848cf0ab31f5b271b">getDefault</a> (const std::string &amp;key) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the default values with specified key.  <a href="#a9536505f283c0fc848cf0ab31f5b271b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#ad0e11287725b2597aa2fd24aa164de5f">setProperty</a> (const std::string &amp;key, const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a value associated with key in the property list.  <a href="#ad0e11287725b2597aa2fd24aa164de5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a019205d917bb9fadfedd5d2a6143b88a">setDefault</a> (const std::string &amp;key, const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a default value associated with key in the property list.  <a href="#a019205d917bb9fadfedd5d2a6143b88a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a66d2d6f4814a45c55d2e85a3e8f5a8c0">setDefaults</a> (const char *defaults[], long num=LONG_MAX)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a default value together in the property list.  <a href="#a66d2d6f4814a45c55d2e85a3e8f5a8c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#afe0899928af5de6b6b6b3226e4bf228a">list</a> (std::ostream &amp;out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints this property list out to the specified output stream.  <a href="#afe0899928af5de6b6b6b3226e4bf228a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a3eb4ac76be20037552ec34f1ca7923b1">load</a> (std::istream &amp;inStream)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads property list that consists of key:value from input stream.  <a href="#a3eb4ac76be20037552ec34f1ca7923b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#aef5ed6f0e17adabfc46e4c5d3de2580d">save</a> (std::ostream &amp;out, const std::string &amp;header)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save the property list to the specified stream.  <a href="#aef5ed6f0e17adabfc46e4c5d3de2580d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a86d929fdcba713269d59239d32dfd1b5">store</a> (std::ostream &amp;out, const std::string &amp;header)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores property list to the output stream.  <a href="#a86d929fdcba713269d59239d32dfd1b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a32285ad4eba53bad4f9b37d19fd2f088">propertyNames</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an vector of all the keys in this property.  <a href="#a32285ad4eba53bad4f9b37d19fd2f088"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#af57a98d78e63f9429d0bd656dc3c2db3">size</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a>.  <a href="#af57a98d78e63f9429d0bd656dc3c2db3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoil_1_1Properties.html">Properties</a> *const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a9da22dbbf05a2115f4a8a1d4fcc8f883">findNode</a> (const std::string &amp;key) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get node of properties.  <a href="#a9da22dbbf05a2115f4a8a1d4fcc8f883"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a96cd29523b03679abf8ace55cb84ac36">getNode</a> (const std::string &amp;key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get node of properties.  <a href="#a96cd29523b03679abf8ace55cb84ac36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a866607797f36b9d10a93072d62188150">createNode</a> (const std::string &amp;key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create newly node of <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a>.  <a href="#a866607797f36b9d10a93072d62188150"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoil_1_1Properties.html">Properties</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a4eb696904cc8a1c0ae9fa5bcc4a07b75">removeNode</a> (const char *leaf_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove node of <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a>.  <a href="#a4eb696904cc8a1c0ae9fa5bcc4a07b75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoil_1_1Properties.html">Properties</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a0f290b8337860bf7fa677e7c849f30f2">hasKey</a> (const char *key) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether key exists in the children.  <a href="#a0f290b8337860bf7fa677e7c849f30f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a4d9c54809d93b618fc3bcafb50ed1e5a">clear</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the children.  <a href="#a4d9c54809d93b618fc3bcafb50ed1e5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a74de44746be25fa0a404bd17c02cda44">operator&lt;&lt;</a> (const <a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;prop)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge properties.  <a href="#a74de44746be25fa0a404bd17c02cda44"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a6164ce725d1349d11d6d7c349b6b8cc1">splitKeyValue</a> (const std::string &amp;str, std::string &amp;key, std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split the string into a pair of the key and the value.  <a href="#a6164ce725d1349d11d6d7c349b6b8cc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a510ba2a11821c01d0d39c11d05dfced8">split</a> (const std::string &amp;str, const char delim, std::vector&lt; std::string &gt; &amp;value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split the string.  <a href="#a510ba2a11821c01d0d39c11d05dfced8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcoil_1_1Properties.html">Properties</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a0fc03588997dcb27fe602b4cc05f2177">_getNode</a> (std::vector&lt; std::string &gt; &amp;keys, std::vector&lt; <a class="el" href="classcoil_1_1Properties.html">Properties</a> * &gt;::size_type index, const <a class="el" href="classcoil_1_1Properties.html">Properties</a> *curr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get properties.  <a href="#a0fc03588997dcb27fe602b4cc05f2177"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a1955392bd669df6b34d63a97343ccadb">_propertiyNames</a> (std::vector&lt; std::string &gt; &amp;names, std::string curr_name, const <a class="el" href="classcoil_1_1Properties.html">Properties</a> *curr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get property name list.  <a href="#a1955392bd669df6b34d63a97343ccadb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a1818545c1410c07de326d202391d678d">_store</a> (std::ostream &amp;out, std::string curr_name, <a class="el" href="classcoil_1_1Properties.html">Properties</a> *curr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the property name list.  <a href="#a1818545c1410c07de326d202391d678d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#ad61ec669343b61db27b721ebcd1f13a6">_dump</a> (std::ostream &amp;out, const <a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;curr, int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save property's contents.  <a href="#ad61ec669343b61db27b721ebcd1f13a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#ad238d41d4cacaefb479f0ba35e75fa77">indent</a> (int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create indents.  <a href="#ad238d41d4cacaefb479f0ba35e75fa77"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoil_1_1Properties.html#a4cbe3c065a17f9e6119dc2f423db16da">operator&lt;&lt;</a> (std::ostream &amp;lhs, const <a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> to stream.  <a href="#a4cbe3c065a17f9e6119dc2f423db16da"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class represents a set of properties. </p>
<p>The <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> class represents a persistent set of properties. The <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> can be saved to a stream or loaded from a stream. Each key and its corresponding value in the property list is a string.</p>
<p>A property list can contain another property list as its "defaults". This second property list is searched if the property key is not found in the original property list.</p>
<p>It is recommended to use these method; <a class="el" href="classcoil_1_1Properties.html#ad0e11287725b2597aa2fd24aa164de5f" title="Set a value associated with key in the property list.">setProperty()</a> to get properties, <a class="el" href="classcoil_1_1Properties.html#ad0e11287725b2597aa2fd24aa164de5f" title="Set a value associated with key in the property list.">setProperty()</a> to set properties.</p>
<p>When propertis are stored in a stream or when they are loaded from the stream, the ISO 8859-1 character encoding is used. Characters that cannot be directly represented in this encoding can be used.</p>
<p>This class has almost same methods of Java's <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> class (java.util.Properties). Also, input and output files are compatible with outputs of Java's <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> class, but Unicode encoded property file is not be supported. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac450ea6ec45f1166cc630bbc26535a00"></a><!-- doxytag: member="coil::Properties::Properties" ref="ac450ea6ec45f1166cc630bbc26535a00" args="(const char *key=&quot;&quot;, const char *value=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">coil::Properties::Properties </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor(Create only root node). </p>
<p>Create a root node of Property with root's key and value. All values are set as default value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Properties's keys(The default values:"") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Properties's values(The default values:"") </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a220dd189b126cb4faeea1c6849512667"></a><!-- doxytag: member="coil::Properties::Properties" ref="a220dd189b126cb4faeea1c6849512667" args="(std::map&lt; std::string, std::string &gt; &amp;defaults)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">coil::Properties::Properties </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>defaults</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor(Give the default value with map). </p>
<p>Create <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> with default value of std::string map. All values are set as default value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>defaults</em>&nbsp;</td><td>map that is spcified as the default value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae93d761ca0f93dfe41be33b67a2b2741"></a><!-- doxytag: member="coil::Properties::Properties" ref="ae93d761ca0f93dfe41be33b67a2b2741" args="(const char *defaults[], long num=LONG_MAX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">coil::Properties::Properties </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>defaults</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>num</em> = <code>LONG_MAX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor(Give the default value with char*[]). </p>
<p>Creates an empty property list with the specified defaults. All values are set as the default values. The default values are given by array of char*, which should be pairs of "key" and "value". The end of list is specified by argument "num" which specifies number of array, or null character of key. The following is an example.</p>
<pre>
 const char* defaults = {
     "key1", "value1",
     "key2", "value2",
     "key3", "value3",
     "key4", "value4",
     "key5", "value5",
     "" };
 <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> p(defaults);
 // or
 <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> p(defaults, 10);
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>defaults</em>&nbsp;</td><td>Array that specifies the default values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>Number of elements that specifies the default value (The default value:LONG_MAX) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebf43709176e3a922290bd762544ce41"></a><!-- doxytag: member="coil::Properties::Properties" ref="aebf43709176e3a922290bd762544ce41" args="(const Properties &amp;prop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">coil::Properties::Properties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prop</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy Constructor. </p>
<p>All of given Properties's keys, values and default values are copied to new <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a>. </p>

</div>
</div>
<a class="anchor" id="a1edb4ee99d0a187307687bf7472efe3d"></a><!-- doxytag: member="coil::Properties::~Properties" ref="a1edb4ee99d0a187307687bf7472efe3d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual coil::Properties::~Properties </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad61ec669343b61db27b721ebcd1f13a6"></a><!-- doxytag: member="coil::Properties::_dump" ref="ad61ec669343b61db27b721ebcd1f13a6" args="(std::ostream &amp;out, const Properties &amp;curr, int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::ostream&amp; coil::Properties::_dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save property's contents. </p>
<p>Save the contents that were set to the property. The figure represented the depth of the property hierarchy is added when saving. If property with the value that is not set, the default value will be output.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>Output stream of property's contents of save destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curr</em>&nbsp;</td><td>Target property </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Current property hierarchy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fc03588997dcb27fe602b4cc05f2177"></a><!-- doxytag: member="coil::Properties::_getNode" ref="a0fc03588997dcb27fe602b4cc05f2177" args="(std::vector&lt; std::string &gt; &amp;keys, std::vector&lt; Properties * &gt;::size_type index, const Properties *curr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcoil_1_1Properties.html">Properties</a>* coil::Properties::_getNode </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcoil_1_1Properties.html">Properties</a> * &gt;::size_type&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoil_1_1Properties.html">Properties</a> *&nbsp;</td>
          <td class="paramname"> <em>curr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get properties. </p>
<p>Get properties specified by key list. In the key list, hierarchical relation in the properties is represented by a list format. If properties corresponding to specified key list do not exist, null will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>Target properties's key list representation for getting </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Number of hierarchy of key list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curr</em>&nbsp;</td><td>Target properties for the search</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Target properties for the search </dd></dl>

</div>
</div>
<a class="anchor" id="a1955392bd669df6b34d63a97343ccadb"></a><!-- doxytag: member="coil::Properties::_propertiyNames" ref="a1955392bd669df6b34d63a97343ccadb" args="(std::vector&lt; std::string &gt; &amp;names, std::string curr_name, const Properties *curr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void coil::Properties::_propertiyNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>curr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoil_1_1Properties.html">Properties</a> *&nbsp;</td>
          <td class="paramname"> <em>curr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get property name list. </p>
<p>Get a list expressed by separating each property name with '.'.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>Name list of property </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curr_name</em>&nbsp;</td><td>Current property's name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curr</em>&nbsp;</td><td>Target properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1818545c1410c07de326d202391d678d"></a><!-- doxytag: member="coil::Properties::_store" ref="a1818545c1410c07de326d202391d678d" args="(std::ostream &amp;out, std::string curr_name, Properties *curr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void coil::Properties::_store </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>curr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcoil_1_1Properties.html">Properties</a> *&nbsp;</td>
          <td class="paramname"> <em>curr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store the property name list. </p>
<p>Store a list expressed by separating each property name with '.'.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>Output stream of property's name list of save destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curr_name</em>&nbsp;</td><td>Current property's name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curr</em>&nbsp;</td><td>Target properties </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d9c54809d93b618fc3bcafb50ed1e5a"></a><!-- doxytag: member="coil::Properties::clear" ref="a4d9c54809d93b618fc3bcafb50ed1e5a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coil::Properties::clear </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the children. </p>

</div>
</div>
<a class="anchor" id="a866607797f36b9d10a93072d62188150"></a><!-- doxytag: member="coil::Properties::createNode" ref="a866607797f36b9d10a93072d62188150" args="(const std::string &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool coil::Properties::createNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create newly node of <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a>. </p>
<p>Create nowly node with specified key. If the node with the same key has been registered, error will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Newly node key</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Newly node creation result. false will be returned if the node with specified key has already existed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9da22dbbf05a2115f4a8a1d4fcc8f883"></a><!-- doxytag: member="coil::Properties::findNode" ref="a9da22dbbf05a2115f4a8a1d4fcc8f883" args="(const std::string &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoil_1_1Properties.html">Properties</a>* const coil::Properties::findNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get node of properties. </p>
<p>Get node with specified key.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Target node key for getting</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Target node </dd></dl>

</div>
</div>
<a class="anchor" id="a9536505f283c0fc848cf0ab31f5b271b"></a><!-- doxytag: member="coil::Properties::getDefault" ref="a9536505f283c0fc848cf0ab31f5b271b" args="(const std::string &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; coil::Properties::getDefault </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the default values with specified key. </p>
<p>Return the default values with specified key. If the property with specified key does not exist, the method returns empty string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The property key</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value in this property list with the specified key value. </dd></dl>

</div>
</div>
<a class="anchor" id="a78d23bd777bb462168a1807750267d6d"></a><!-- doxytag: member="coil::Properties::getDefaultValue" ref="a78d23bd777bb462168a1807750267d6d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* coil::Properties::getDefaultValue </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get default values. </p>
<p>Get Properties's default values.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Properties's default values </dd></dl>

</div>
</div>
<a class="anchor" id="a51cdcfada7734595f8a58beaa4356c72"></a><!-- doxytag: member="coil::Properties::getLeaf" ref="a51cdcfada7734595f8a58beaa4356c72" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classcoil_1_1Properties.html">Properties</a>*&gt;&amp; coil::Properties::getLeaf </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get elements of leaf. </p>
<p>Get Properties's elements of leaf.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Elements of leaf </dd></dl>

</div>
</div>
<a class="anchor" id="a3809685330fc7d8ced176e8dbe8dd2f7"></a><!-- doxytag: member="coil::Properties::getName" ref="a3809685330fc7d8ced176e8dbe8dd2f7" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* coil::Properties::getName </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Names. </p>
<p>Get Properties's names.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Properties's names </dd></dl>

</div>
</div>
<a class="anchor" id="a96cd29523b03679abf8ace55cb84ac36"></a><!-- doxytag: member="coil::Properties::getNode" ref="a96cd29523b03679abf8ace55cb84ac36" args="(const std::string &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoil_1_1Properties.html">Properties</a>&amp; coil::Properties::getNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get node of properties. </p>
<p>Get node with specified key.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Target node key for getting</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Target node </dd></dl>

</div>
</div>
<a class="anchor" id="ac79dfbccc6050fcf4631063d1090af87"></a><!-- doxytag: member="coil::Properties::getProperty" ref="ac79dfbccc6050fcf4631063d1090af87" args="(const std::string &amp;key, const std::string &amp;def) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; coil::Properties::getProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>def</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for the property with the specified key in property list. </p>
<p>Search for the property with the specified key in this property list. The method returns the default value argument if the property is not found.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The property key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>def</em>&nbsp;</td><td>The default value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value in this property list with the specified key value. </dd></dl>

</div>
</div>
<a class="anchor" id="a91ad72f8d7c41624e2258c5a9331bd2a"></a><!-- doxytag: member="coil::Properties::getProperty" ref="a91ad72f8d7c41624e2258c5a9331bd2a" args="(const std::string &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; coil::Properties::getProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for the property with the specified key in this property. </p>
<p>Search for the property with the specified key in this property list. If the key is not found in this property list, the default property list, and its defaults, recursively, are then checked. The method returns null if the property is not found.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The property key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value in this property list with the specified key value. </dd></dl>

<p>Referenced by <a class="el" href="ModuleManager_8h_source.html#l00693">RTC::ModuleManager::DllPred::operator()()</a>, <a class="el" href="Manager_8h_source.html#l01822">RTC::Manager::ModuleFactories::operator()()</a>, and <a class="el" href="ConnectorListener_8h_source.html#l00326">RTC::ConnectorDataListenerT&lt; DataType &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a930c4db15600de4f49370741652221cf"></a><!-- doxytag: member="coil::Properties::getRoot" ref="a930c4db15600de4f49370741652221cf" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcoil_1_1Properties.html">Properties</a>* coil::Properties::getRoot </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get root element. </p>
<p>Get Properties's root element.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Root element </dd></dl>

</div>
</div>
<a class="anchor" id="aa402bd7d600a60560782622ef7ece205"></a><!-- doxytag: member="coil::Properties::getValue" ref="aa402bd7d600a60560782622ef7ece205" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* coil::Properties::getValue </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get values. </p>
<p>Get Properties's values.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Properties's values </dd></dl>

</div>
</div>
<a class="anchor" id="a0f290b8337860bf7fa677e7c849f30f2"></a><!-- doxytag: member="coil::Properties::hasKey" ref="a0f290b8337860bf7fa677e7c849f30f2" args="(const char *key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoil_1_1Properties.html">Properties</a>* coil::Properties::hasKey </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether key exists in the children. </p>
<p>Check whether the children with specified key exist. If the children exist, they will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Check key</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Children node </dd></dl>

</div>
</div>
<a class="anchor" id="ad238d41d4cacaefb479f0ba35e75fa77"></a><!-- doxytag: member="coil::Properties::indent" ref="ad238d41d4cacaefb479f0ba35e75fa77" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::string coil::Properties::indent </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create indents. </p>
<p>Return indents according to specified figure. Returned indents are specified figure x two blanks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The specification of Number of indent</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Created indent </dd></dl>

</div>
</div>
<a class="anchor" id="afe0899928af5de6b6b6b3226e4bf228a"></a><!-- doxytag: member="coil::Properties::list" ref="afe0899928af5de6b6b6b3226e4bf228a" args="(std::ostream &amp;out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coil::Properties::list </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints this property list out to the specified output stream. </p>
<p>Prints this property list out to the specified output stream. This method is useful for debugging.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>Output stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3eb4ac76be20037552ec34f1ca7923b1"></a><!-- doxytag: member="coil::Properties::load" ref="a3eb4ac76be20037552ec34f1ca7923b1" args="(std::istream &amp;inStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coil::Properties::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>inStream</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads property list that consists of key:value from input stream. </p>
<p>Reads a property list (key and element pairs) from the input stream. The stream is assumed to be using the ISO 8859-1 character encoding. Each property is assumed to be registered in the input stream by each line, and each line terminator is should be a line break characters (\n or \r or \r\n). Lines are read from the input stream until end of file is reached.</p>
<p>A line that contains only white space characters or a line that its first non-white space character is an ASCII '#' or '!' is ignored. In a word, '#' or '!' represents comment lines.</p>
<p>All lines except the blank line or comment line is described the property that added to the table. However, if the line terminator is '\' and the next line continues, it is treated as a continuation line (See below). The key is composed of all characters. All of these key termination characters in the line starting with the first non-white space character and up to, but not including, the first unescaped '=', ':', or white space character other than a line terminator.</p>
<p>Line terminator characters can be included using \ escape sequences. Any white space after the key is skipped. If the first non-white space character after the key is '=' or ':', then it is ignored and any white space characters after it are also skipped. All remaining characters on the line become part of the associated element string. In element string, ASCII escape sequence such as \t and \n and \r and \\ and \" and \' and \ (backslash character and space) and \uxxxx have affect and they will be converted into a single character. Also, if termination character in the line is \, the next line will be treated as continuing. In that case, \ and break character will be destroyed, and also its first space character will be destroyed, so these characters on the line will not become part of the element string.</p>
<p>As an example, each of the following three lines specifies the key "Truth" and the associated element value "Beauty":</p>
<p>Truth = Beauty <br/>
 Truth:Beauty <br/>
 Truth\t\t\t:Beauty <br/>
</p>
<p>As another example, the following three lines specify a single property:</p>
<p>fruits\t\t\t\tapple, banana, pear, \ <br/>
 cantaloupe, watermelon, \ <br/>
 kiwi, mango <br/>
 The key is "fruits" and the associated element is: "apple, banana, pear, cantaloupe, watermelon, kiwi, mango". Note that a space appears before each \ so that a space will each comma in the final result; the \, line terminator, and leading white space on the continuation line are merely discarded and are not replaced by one or more other characters. As a third example, the line:</p>
<p>cheeses <br/>
 specifies that the key is "cheeses" and the associated element is the empty string "".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inStream</em>&nbsp;</td><td>the input stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74de44746be25fa0a404bd17c02cda44"></a><!-- doxytag: member="coil::Properties::operator&lt;&lt;" ref="a74de44746be25fa0a404bd17c02cda44" args="(const Properties &amp;prop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoil_1_1Properties.html">Properties</a>&amp; coil::Properties::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prop</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge properties. </p>
<p>Merge properties that have set to the current properties.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prop</em>&nbsp;</td><td><a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> for the merge</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Property merge result </dd></dl>

</div>
</div>
<a class="anchor" id="acf1a3c8e401765c285e318d6863a6e77"></a><!-- doxytag: member="coil::Properties::operator=" ref="acf1a3c8e401765c285e318d6863a6e77" args="(const Properties &amp;prop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoil_1_1Properties.html">Properties</a>&amp; coil::Properties::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prop</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>
<p>All Properties's keys, values and default values of left side are deleted, all Properties's keys, values and default values of right side are copied to new <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a>. </p>

</div>
</div>
<a class="anchor" id="a2c241eddb268f07442e1d008154b2fef"></a><!-- doxytag: member="coil::Properties::operator[]" ref="a2c241eddb268f07442e1d008154b2fef" args="(const std::string &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; coil::Properties::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for the property with the specified key in property list. </p>
<p>Search for the property with the specified key in this property list. If the key is not found in this property list, the default property list, and its defaults, recursively, are then checked. The method returns empty string if the property is not found. If there is no element with the same value in the left value, insert the right value in corresponding property.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The property key</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value in this property list with the specified key value. </dd></dl>

</div>
</div>
<a class="anchor" id="a184d704a37d9eb2052b77a0624060b34"></a><!-- doxytag: member="coil::Properties::operator[]" ref="a184d704a37d9eb2052b77a0624060b34" args="(const std::string &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; coil::Properties::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for the property with the specified key in property list. </p>
<p>Search for the property with the specified key in this property list. If the key is not found in this property list, the default property list, and its defaults, recursively, are then checked. The method returns empty string if the property is not found.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The property key</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value in this property list with the specified key value. </dd></dl>

</div>
</div>
<a class="anchor" id="a32285ad4eba53bad4f9b37d19fd2f088"></a><!-- doxytag: member="coil::Properties::propertyNames" ref="a32285ad4eba53bad4f9b37d19fd2f088" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; coil::Properties::propertyNames </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an vector of all the keys in this property. </p>
<p>Returns an enumeration of all the keys in this property list, including distinct keys in the default property list if a key of the same name has not already been found from the main properties list.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of all the keys in this property list, including the keys in the default property list. </dd></dl>

</div>
</div>
<a class="anchor" id="a4eb696904cc8a1c0ae9fa5bcc4a07b75"></a><!-- doxytag: member="coil::Properties::removeNode" ref="a4eb696904cc8a1c0ae9fa5bcc4a07b75" args="(const char *leaf_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoil_1_1Properties.html">Properties</a>* coil::Properties::removeNode </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>leaf_name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove node of <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a>. </p>
<p>Remove properties with specified name. <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> that were deleted will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leaf_name</em>&nbsp;</td><td>Target property's name for the delete</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Deleted properties </dd></dl>

</div>
</div>
<a class="anchor" id="aef5ed6f0e17adabfc46e4c5d3de2580d"></a><!-- doxytag: member="coil::Properties::save" ref="aef5ed6f0e17adabfc46e4c5d3de2580d" args="(std::ostream &amp;out, const std::string &amp;header)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coil::Properties::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>header</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save the property list to the specified stream. </p>
<p>It is not recommended. To save the property list, the store(ostream out, string header) method is recommended. This method is defined for compatibility of Java <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>The output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>header</em>&nbsp;</td><td>A description of the property list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a019205d917bb9fadfedd5d2a6143b88a"></a><!-- doxytag: member="coil::Properties::setDefault" ref="a019205d917bb9fadfedd5d2a6143b88a" args="(const std::string &amp;key, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string coil::Properties::setDefault </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a default value associated with key in the property list. </p>
<p>Set the default value to element specified by "key".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Property's key to set the default value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The default value that is set</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The specified default value </dd></dl>

</div>
</div>
<a class="anchor" id="a66d2d6f4814a45c55d2e85a3e8f5a8c0"></a><!-- doxytag: member="coil::Properties::setDefaults" ref="a66d2d6f4814a45c55d2e85a3e8f5a8c0" args="(const char *defaults[], long num=LONG_MAX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coil::Properties::setDefaults </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>defaults</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>num</em> = <code>LONG_MAX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a default value together in the property list. </p>
<p>Set the default value to the element specified by array together in the property list. The default values are given by array of char*, which should be pairs of "key" and "value". The end of list is specified by argument "num", which specifies number of array or null character of key.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>defaults</em>&nbsp;</td><td>Array that specifies the default values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>Number of elements that specifies the default value (Default value:LONG_MAX) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0e11287725b2597aa2fd24aa164de5f"></a><!-- doxytag: member="coil::Properties::setProperty" ref="ad0e11287725b2597aa2fd24aa164de5f" args="(const std::string &amp;key, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string coil::Properties::setProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a value associated with key in the property list. </p>
<p>This method sets the "value" associated with "key" in the property list. If the property list has a value of "key", old value is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to be placed into this property list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value corresponding to key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The previous value of the specified key in this property list, or null if it did not have one. </dd></dl>

</div>
</div>
<a class="anchor" id="af57a98d78e63f9429d0bd656dc3c2db3"></a><!-- doxytag: member="coil::Properties::size" ref="af57a98d78e63f9429d0bd656dc3c2db3" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coil::Properties::size </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a>. </p>
<p>Get the number of <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> that has already set.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a510ba2a11821c01d0d39c11d05dfced8"></a><!-- doxytag: member="coil::Properties::split" ref="a510ba2a11821c01d0d39c11d05dfced8" args="(const std::string &amp;str, const char delim, std::vector&lt; std::string &gt; &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool coil::Properties::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split the string. </p>
<p>Divide given string with given delimiter. If the given string is empty, error will be returned. When the given delimiter is escaped ('\' is set right before it) this method does not use as delimiter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Target string for the division </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>Delimiter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Division result list</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Division result </dd></dl>

</div>
</div>
<a class="anchor" id="a6164ce725d1349d11d6d7c349b6b8cc1"></a><!-- doxytag: member="coil::Properties::splitKeyValue" ref="a6164ce725d1349d11d6d7c349b6b8cc1" args="(const std::string &amp;str, std::string &amp;key, std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void coil::Properties::splitKeyValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split the string into a pair of the key and the value. </p>
<p>Split the given string into a pair of the key and the value with the set delimiter. First, search whether the fist given string includes ':' or '=', and if either character is included, it is used as delimiter. If neither is included, try to divide it with ' '(space). When all delimiter candidates are not included, set the given string as key then set empty string to the its value. If any delimiter candidate is escaped ('\' is set right before it), this method does not use as delimiter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Target string for the division </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Division result key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Division result value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86d929fdcba713269d59239d32dfd1b5"></a><!-- doxytag: member="coil::Properties::store" ref="a86d929fdcba713269d59239d32dfd1b5" args="(std::ostream &amp;out, const std::string &amp;header)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coil::Properties::store </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>header</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores property list to the output stream. </p>
<p>Write this property list (key and element pairs) in this <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> table to the output stream in a format suitable for loading into a <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> table using the load method. The stream is written using the ISO 8859-1 character encoding. <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> from the defaults table of this <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> table (if any) are not written out by this method.</p>
<p>If the header argument is not null, then an ASCII # character, the comments string, and a line separator are first written to the output stream. Thus, the header can serve as an identifying comment.</p>
<p>Next, a comment line is always written, consisting of an ASCII # character, the current date and time (as if produced by the toString method of Date for the current time), and a line separator as generated by the Writer.</p>
<p>Then every entry in this <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> table is written out, one per line. For each entry the key string is written, then an ASCII =, then the associated element string. Each character of the key and element strings is examined to see whether it should be rendered as an escape sequence. The ASCII characters \, tab, form feed, newline, and carriage return are written as \\, \t, \f \n, and \r, respectively. Characters less than \u0020 and characters greater than \u007E are written as \uxxxx for the appropriate hexadecimal value xxxx. For the key, all space characters are written with a preceding \ character. For the element, leading space characters, but not embedded or trailing space characters, are written with a preceding \ character. The key and element characters #, !, =, and : are written with a preceding backslash to ensure that they are properly loaded.</p>
<p>After the entries have been written, the output stream is flushed. The output stream remains open after this method returns.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>An output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>header</em>&nbsp;</td><td>The description of the property list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a4cbe3c065a17f9e6119dc2f423db16da"></a><!-- doxytag: member="coil::Properties::operator&lt;&lt;" ref="a4cbe3c065a17f9e6119dc2f423db16da" args="(std::ostream &amp;lhs, const Properties &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcoil_1_1Properties.html">Properties</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> to stream. </p>
<p>Output <a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a> to stream.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lhs</em>&nbsp;</td><td>Output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td><a class="el" href="classcoil_1_1Properties.html" title="Class represents a set of properties.">Properties</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Output stream </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu May 24 23:25:21 2012 for OpenRTM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
