<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenRTM: RTC::OutPortConsumer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceRTC.html">RTC</a>::<a class="el" href="classRTC_1_1OutPortConsumer.html">OutPortConsumer</a>
  </div>
</div>
<div class="contents">
<h1>RTC::OutPortConsumer Class Reference</h1><!-- doxytag: class="RTC::OutPortConsumer" --><!-- doxytag: inherits="RTC::DataPortStatus" -->
<p><a class="el" href="classRTC_1_1OutPortConsumer.html" title="OutPortConsumer abstract class.">OutPortConsumer</a> abstract class.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OutPortConsumer_8h_source.html">OutPortConsumer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTC::OutPortConsumer:</div>
<div class="dynsection">
 <div class="center">
  <img src="classRTC_1_1OutPortConsumer.png" usemap="#RTC::OutPortConsumer_map" alt=""/>
  <map id="RTC::OutPortConsumer_map" name="RTC::OutPortConsumer_map">
<area href="classRTC_1_1DataPortStatus.html" alt="RTC::DataPortStatus" shape="rect" coords="0,0,198,24"/>
<area href="classRTC_1_1OutPortCorbaCdrConsumer.html" alt="RTC::OutPortCorbaCdrConsumer" shape="rect" coords="0,112,198,136"/>
</map>
 </div>
</div>

<p><a href="classRTC_1_1OutPortConsumer-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTC_1_1OutPortConsumer_1_1subscribe.html">subscribe</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor to subscribe the interface.  <a href="structRTC_1_1OutPortConsumer_1_1subscribe.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTC_1_1OutPortConsumer_1_1unsubscribe.html">unsubscribe</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor to unsubscribe the interface.  <a href="structRTC_1_1OutPortConsumer_1_1unsubscribe.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual DATAPORTSTATUS_ENUM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1OutPortConsumer.html#a0d56439ce5cf056bb09ad5de4631d4b4">~OutPortConsumer</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a0d56439ce5cf056bb09ad5de4631d4b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1OutPortConsumer.html#ab746873de12fd0fb1d8bf37e79192e54">init</a> (<a class="el" href="classcoil_1_1Properties.html">coil::Properties</a> &amp;prop)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializing configuration.  <a href="#ab746873de12fd0fb1d8bf37e79192e54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1OutPortConsumer.html#a78e11b4a34b7de7a11efd06809a38c1a">setBuffer</a> (<a class="el" href="classRTC_1_1BufferBase.html">CdrBufferBase</a> *buffer)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting outside buffer's pointer.  <a href="#a78e11b4a34b7de7a11efd06809a38c1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1OutPortConsumer.html#a19b78db46c31332782bf122f5e12e09b">setListener</a> (<a class="el" href="classRTC_1_1ConnectorInfo.html">ConnectorInfo</a> &amp;info, <a class="el" href="classRTC_1_1ConnectorListeners.html">ConnectorListeners</a> *listeners)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the listener.  <a href="#a19b78db46c31332782bf122f5e12e09b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1OutPortConsumer.html#acd8302e6ded9e796afb047aff0bc1c0e">get</a> (cdrMemoryStream &amp;data)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive data.  <a href="#acd8302e6ded9e796afb047aff0bc1c0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1OutPortConsumer.html#a84bc467a9540b1eef126feec41551328">subscribeInterface</a> (const SDOPackage::NVList &amp;properties)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subscribe the data receive notification.  <a href="#a84bc467a9540b1eef126feec41551328"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1OutPortConsumer.html#a81f847f4cc94889811ad5638764c8a24">unsubscribeInterface</a> (const SDOPackage::NVList &amp;properties)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsubscribe the data receive notification.  <a href="#a81f847f4cc94889811ad5638764c8a24"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTC_1_1Logger.html">Logger</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1OutPortConsumer.html#a7ea8593f77acf37f7a249fed53528d99">rtclog</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classRTC_1_1Logger.html" title="Logger class.">Logger</a> stream.  <a href="#a7ea8593f77acf37f7a249fed53528d99"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classRTC_1_1OutPortConsumer.html" title="OutPortConsumer abstract class.">OutPortConsumer</a> abstract class. </p>
<p>The virtual class for OutPort's PROVIDED interface implementation. New interface for <a class="el" href="classRTC_1_1OutPort.html" title="OutPort template class.">OutPort</a> have to inherit this class, and have to implement the following functions.</p>
<ul>
<li><a class="el" href="classRTC_1_1OutPortConsumer.html#ab746873de12fd0fb1d8bf37e79192e54" title="Initializing configuration.">init()</a></li>
<li><a class="el" href="classRTC_1_1OutPortConsumer.html#a78e11b4a34b7de7a11efd06809a38c1a" title="Setting outside buffer&#39;s pointer.">setBuffer()</a></li>
<li><a class="el" href="classRTC_1_1OutPortConsumer.html#a19b78db46c31332782bf122f5e12e09b" title="Set the listener.">setListener()</a></li>
<li><a class="el" href="classRTC_1_1OutPortConsumer.html#acd8302e6ded9e796afb047aff0bc1c0e" title="Receive data.">get()</a></li>
</ul>
<p>Furthermore, connecting or disconnecting processes, such as obtaining some information from ConnectorProfile or releasing some resources, should be implemented in the following virtual functions.</p>
<ul>
<li><a class="el" href="classRTC_1_1OutPortConsumer.html#a84bc467a9540b1eef126feec41551328" title="Subscribe the data receive notification.">subscribeInterface()</a></li>
<li><a class="el" href="classRTC_1_1OutPortConsumer.html#a81f847f4cc94889811ad5638764c8a24" title="Unsubscribe the data receive notification.">unsubscribeInterface()</a></li>
</ul>
<p><a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> inquires available OutPortConsumers to the factory class of <a class="el" href="classRTC_1_1OutPortConsumer.html" title="OutPortConsumer abstract class.">OutPortConsumer</a>, and publishes available interfaces to others. Therefore, sub-classes of <a class="el" href="classRTC_1_1OutPortConsumer.html" title="OutPortConsumer abstract class.">OutPortConsumer</a> that provides PROVIDED interface to <a class="el" href="classRTC_1_1OutPort.html" title="OutPort template class.">OutPort</a> should register its factory to OutPortConsumerFactory.</p>
<p><a class="el" href="classcoil_1_1Singleton.html#aea119e0534a0de4b63a8f84c7d68b223" title="Create instance.">RTC::OutPortConsumerFactory::instance()</a>.addFactory() would be called with the following arguments.</p>
<p>1st arg: The name of provider. ex. "corba_cdr" 2nd arg: Factory function. <a class="el" href="namespacecoil.html#a7f96c97693a425d037804baac00e095a" title="Creator template.">coil::Creator&lt;B, T&gt;</a> 3rd arg: Destruction function. <a class="el" href="namespacecoil.html#a3d92b40c32da6da798031e58bb1c2cf0" title="Destructor template.">coil::Destructor&lt;B, T&gt;</a></p>
<p>The following example shows how to register factory function. And it is also declared as a initialization function.</p>
<pre>
 extern "C"
 {
   void <a class="el" href="OutPortCorbaCdrConsumer_8h.html#a5f77e05ce32d3ac8ae8cd0a99f003347" title="Module initialization.">OutPortCorbaCdrConsumerInit(void)</a>
   {
     <a class="el" href="namespaceRTC.html#a3348783eadec0be081480ddb03a27328" title="OutPortConsumerFactory type definition.">RTC::OutPortConsumerFactory</a>&amp;
                         factory(<a class="el" href="classcoil_1_1Singleton.html#aea119e0534a0de4b63a8f84c7d68b223" title="Create instance.">RTC::OutPortConsumerFactory::instance()</a>);
     factory.addFactory("corba_cdr",
                        coil::Creator&lt;<a class="el" href="classRTC_1_1OutPortConsumer.html" title="OutPortConsumer abstract class.">RTC::OutPortConsumer</a>,
                                        <a class="el" href="classRTC_1_1OutPortCorbaCdrConsumer.html" title="OutPortCorbaCdrConsumer class.">RTC::OutPortCorbaCdrConsumer</a>&gt;,
                        coil::Destructor&lt;<a class="el" href="classRTC_1_1OutPortConsumer.html" title="OutPortConsumer abstract class.">RTC::OutPortConsumer</a>,
                                           <a class="el" href="classRTC_1_1OutPortCorbaCdrConsumer.html" title="OutPortCorbaCdrConsumer class.">RTC::OutPortCorbaCdrConsumer</a>&gt;);
   }
 };
 </pre><p>It is recommended that the registration process is declared as a initialization function with "extern C" to be accessed from the outside of module. If the OutPortConsumers are compiled as a shared object or DLL for dynamic loading, new <a class="el" href="classRTC_1_1OutPortConsumer.html" title="OutPortConsumer abstract class.">OutPortConsumer</a> types can be added dynamically.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>0.4.0 </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0d56439ce5cf056bb09ad5de4631d4b4"></a><!-- doxytag: member="RTC::OutPortConsumer::~OutPortConsumer" ref="a0d56439ce5cf056bb09ad5de4631d4b4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual DATAPORTSTATUS_ENUM RTC::OutPortConsumer::~OutPortConsumer </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Virtual destructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acd8302e6ded9e796afb047aff0bc1c0e"></a><!-- doxytag: member="RTC::OutPortConsumer::get" ref="acd8302e6ded9e796afb047aff0bc1c0e" args="(cdrMemoryStream &amp;data)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode RTC::OutPortConsumer::get </td>
          <td>(</td>
          <td class="paramtype">cdrMemoryStream &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive data. </p>
<p>Pure virtual function to receive data. </p>

<p>Implemented in <a class="el" href="classRTC_1_1OutPortCorbaCdrConsumer.html#a72889a36a5359ed449f569a9f9c64762">RTC::OutPortCorbaCdrConsumer</a>.</p>

</div>
</div>
<a class="anchor" id="ab746873de12fd0fb1d8bf37e79192e54"></a><!-- doxytag: member="RTC::OutPortConsumer::init" ref="ab746873de12fd0fb1d8bf37e79192e54" args="(coil::Properties &amp;prop)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTC::OutPortConsumer::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoil_1_1Properties.html">coil::Properties</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prop</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializing configuration. </p>
<p>This operation would be called to configure in initialization. In the concrete class, configuration should be performed getting appropriate information from the given Properties data. This function might be called right after instantiation and connection sequence respectivly. Therefore, this function should be implemented assuming multiple call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prop</em>&nbsp;</td><td>Configuration information </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classRTC_1_1OutPortCorbaCdrConsumer.html#a2370f34a0600da08bdb57074dc9af5e7">RTC::OutPortCorbaCdrConsumer</a>.</p>

</div>
</div>
<a class="anchor" id="a78e11b4a34b7de7a11efd06809a38c1a"></a><!-- doxytag: member="RTC::OutPortConsumer::setBuffer" ref="a78e11b4a34b7de7a11efd06809a38c1a" args="(CdrBufferBase *buffer)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTC::OutPortConsumer::setBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1BufferBase.html">CdrBufferBase</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting outside buffer's pointer. </p>
<p>A pointer to a buffer from which <a class="el" href="classRTC_1_1OutPortProvider.html" title="OutPortProvider.">OutPortProvider</a> retrieve data. If already buffer is set, previous buffer's pointer will be overwritten by the given pointer to a buffer. Since <a class="el" href="classRTC_1_1OutPortProvider.html" title="OutPortProvider.">OutPortProvider</a> does not assume ownership of the buffer pointer, destructor of the buffer should be done by user.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to a data buffer to be used by <a class="el" href="classRTC_1_1OutPortProvider.html" title="OutPortProvider.">OutPortProvider</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classRTC_1_1OutPortCorbaCdrConsumer.html#a0ce5797c8fbdeded604b75cbfc7022a1">RTC::OutPortCorbaCdrConsumer</a>.</p>

</div>
</div>
<a class="anchor" id="a19b78db46c31332782bf122f5e12e09b"></a><!-- doxytag: member="RTC::OutPortConsumer::setListener" ref="a19b78db46c31332782bf122f5e12e09b" args="(ConnectorInfo &amp;info, ConnectorListeners *listeners)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTC::OutPortConsumer::setListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1ConnectorInfo.html">ConnectorInfo</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTC_1_1ConnectorListeners.html">ConnectorListeners</a> *&nbsp;</td>
          <td class="paramname"> <em>listeners</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the listener. </p>
<p><a class="el" href="classRTC_1_1OutPort.html" title="OutPort template class.">OutPort</a> provides callback functionality that calls specific listener objects according to the events in the data publishing process. For details, see documentation of <a class="el" href="classRTC_1_1ConnectorDataListener.html" title="ConnectorDataListener class.">ConnectorDataListener</a> class and <a class="el" href="classRTC_1_1ConnectorListener.html" title="ConnectorListener class.">ConnectorListener</a> class in <a class="el" href="ConnectorListener_8h.html" title="connector listener class">ConnectorListener.h</a>. In the sub-classes of <a class="el" href="classRTC_1_1OutPortProvider.html" title="OutPortProvider.">OutPortProvider</a>, the given listeners should be called in the proper timing. However, it is not necessary to call all the listeners.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Connector information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>listeners</em>&nbsp;</td><td>Listener objects </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classRTC_1_1OutPortCorbaCdrConsumer.html#a2e9d1d58f46f1c8c286fbd244251e1c8">RTC::OutPortCorbaCdrConsumer</a>.</p>

</div>
</div>
<a class="anchor" id="a84bc467a9540b1eef126feec41551328"></a><!-- doxytag: member="RTC::OutPortConsumer::subscribeInterface" ref="a84bc467a9540b1eef126feec41551328" args="(const SDOPackage::NVList &amp;properties)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RTC::OutPortConsumer::subscribeInterface </td>
          <td>(</td>
          <td class="paramtype">const SDOPackage::NVList &amp;&nbsp;</td>
          <td class="paramname"> <em>properties</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subscribe the data receive notification. </p>
<p>Pure virtual function to subscribe the data receive notification based on specified property information.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>Properties for subscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Subscription result (Successful:true, Failed:false) </dd></dl>

<p>Implemented in <a class="el" href="classRTC_1_1OutPortCorbaCdrConsumer.html#ac0173f06be09ffc9059bda6295d47d4b">RTC::OutPortCorbaCdrConsumer</a>.</p>

<p>Referenced by <a class="el" href="OutPortConsumer_8h_source.html#l00382">RTC::OutPortConsumer::subscribe::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a81f847f4cc94889811ad5638764c8a24"></a><!-- doxytag: member="RTC::OutPortConsumer::unsubscribeInterface" ref="a81f847f4cc94889811ad5638764c8a24" args="(const SDOPackage::NVList &amp;properties)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTC::OutPortConsumer::unsubscribeInterface </td>
          <td>(</td>
          <td class="paramtype">const SDOPackage::NVList &amp;&nbsp;</td>
          <td class="paramname"> <em>properties</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unsubscribe the data receive notification. </p>
<p>Pure virtual function to unsubscribe the data receive notification.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>Properties for unsubscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Unsubscription result (Successful:true, Failed:false) </dd></dl>

<p>Implemented in <a class="el" href="classRTC_1_1OutPortCorbaCdrConsumer.html#a2191f5b9443c7941a197007b95964d0e">RTC::OutPortCorbaCdrConsumer</a>.</p>

<p>Referenced by <a class="el" href="OutPortConsumer_8h_source.html#l00399">RTC::OutPortConsumer::unsubscribe::operator()()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a7ea8593f77acf37f7a249fed53528d99"></a><!-- doxytag: member="RTC::OutPortConsumer::rtclog" ref="a7ea8593f77acf37f7a249fed53528d99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTC_1_1Logger.html">Logger</a> <a class="el" href="classRTC_1_1OutPortConsumer.html#a7ea8593f77acf37f7a249fed53528d99">RTC::OutPortConsumer::rtclog</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classRTC_1_1Logger.html" title="Logger class.">Logger</a> stream. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu May 24 23:25:22 2012 for OpenRTM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
