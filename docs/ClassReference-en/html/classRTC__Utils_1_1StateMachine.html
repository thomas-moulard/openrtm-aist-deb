<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenRTM: RTC_Utils::StateMachine&lt; State, Listener, States, Callback &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceRTC__Utils.html">RTC_Utils</a>::<a class="el" href="classRTC__Utils_1_1StateMachine.html">StateMachine</a>
  </div>
</div>
<div class="contents">
<h1>RTC_Utils::StateMachine&lt; State, Listener, States, Callback &gt; Class Template Reference</h1><!-- doxytag: class="RTC_Utils::StateMachine" -->
<p>State machine class.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StateMachine_8h_source.html">StateMachine.h</a>&gt;</code></p>

<p><a href="classRTC__Utils_1_1StateMachine-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#acca3c5b3e35ae468bde803fd0975f074">StateMachine</a> (int num_of_state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#acca3c5b3e35ae468bde803fd0975f074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a26c9f468d0188e47d891b984f8cd761d">~StateMachine</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a0d232546cd076ffbb0860a612e582416">setNOP</a> (Callback call_back)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set NOP function.  <a href="#a0d232546cd076ffbb0860a612e582416"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#afa4701917d4d6ec2a70f78397519f1f9">setListener</a> (Listener *listener)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set Listener Object.  <a href="#afa4701917d4d6ec2a70f78397519f1f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a611cd79fa4c9257159de08011e7e6509">setEntryAction</a> (State state, Callback call_back)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set Entry action function.  <a href="#a611cd79fa4c9257159de08011e7e6509"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a7bdcc53df08ccb0fa7fb31472613b2fe">setPreDoAction</a> (State state, Callback call_back)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set PreDo action function.  <a href="#a7bdcc53df08ccb0fa7fb31472613b2fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a40da53fd17393b10e4b89b9a63ba1332">setDoAction</a> (State state, Callback call_back)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set Do action function.  <a href="#a40da53fd17393b10e4b89b9a63ba1332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#aad4ee723ecbd2f5c97b358336574c26c">setPostDoAction</a> (State state, Callback call_back)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set PostDo action function.  <a href="#aad4ee723ecbd2f5c97b358336574c26c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#ac308579215117b100ba31c38c31d580a">setExitAction</a> (State state, Callback call_back)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set Exit action function.  <a href="#ac308579215117b100ba31c38c31d580a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a1b18262bc0c7fa8cae25dffd567a0806">setTransitionAction</a> (Callback call_back)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set state transition action function.  <a href="#a1b18262bc0c7fa8cae25dffd567a0806"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a5501ddabd4b93f4e7043708e2de26781">setStartState</a> (States states)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the initial state.  <a href="#a5501ddabd4b93f4e7043708e2de26781"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">States&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#af665f3b667caa54e29dc59a6d5b16d4c">getStates</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get states.  <a href="#af665f3b667caa54e29dc59a6d5b16d4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">State&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a1a768beb5bc5ec5a0e828d0e006d8003">getState</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current state.  <a href="#a1a768beb5bc5ec5a0e828d0e006d8003"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a6338403cf745c61423e310a8b481b9df">isIn</a> (State state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check current state.  <a href="#a6338403cf745c61423e310a8b481b9df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a43b923b77e7e4d3562a83880c488197d">goTo</a> (State state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transit State.  <a href="#a43b923b77e7e4d3562a83880c488197d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#af979deaf6160e247a6a6e3027f31c83b">worker</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Worker function.  <a href="#af979deaf6160e247a6a6e3027f31c83b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a99b23364ce99c4473f3a149383e7230f">setNullFunc</a> (Callback *s, Callback nullfunc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set NOP function.  <a href="#a99b23364ce99c4473f3a149383e7230f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a2503583562749e18c43ca48c6066d9f4">m_num</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of state.  <a href="#a2503583562749e18c43ca48c6066d9f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Listener *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a25f2e293e773fe5c4ffdd49fb343f734">m_listener</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for listener.  <a href="#a25f2e293e773fe5c4ffdd49fb343f734"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Callback *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a728fe8f596c77e326bc356b274144bb5">m_entry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for Entry action.  <a href="#a728fe8f596c77e326bc356b274144bb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Callback *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a687b8b8abab11fb696555fa861240f30">m_predo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for PreDo action.  <a href="#a687b8b8abab11fb696555fa861240f30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Callback *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a86145d8ddee737f186fe019dc84de243">m_do</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for Do action.  <a href="#a86145d8ddee737f186fe019dc84de243"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Callback *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#ac90335d93cc0c173335b130dd91a33e4">m_postdo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for PostDo action.  <a href="#ac90335d93cc0c173335b130dd91a33e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Callback *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a75fb6776bd228a8005eda56e49a33373">m_exit</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for Exit action.  <a href="#a75fb6776bd228a8005eda56e49a33373"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Callback&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#aa292b9b27cf14ea9b82b2ad8b8ddc49d">m_transit</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback function for State transition action.  <a href="#aa292b9b27cf14ea9b82b2ad8b8ddc49d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">States&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#a29e2692dc448060388da12e0a029cfad">m_states</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current state information.  <a href="#a29e2692dc448060388da12e0a029cfad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#aa02af266af8b8e0abf6609abede2a323">m_selftrans</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoil_1_1Mutex.html">Mutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC__Utils_1_1StateMachine.html#aedd1306b007958b49a248d07578214b3">m_mutex</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt;<br/>
 class RTC_Utils::StateMachine&lt; State, Listener, States, Callback &gt;</h3>

<p>State machine class. </p>
<p><a class="el" href="classRTC__Utils_1_1StateMachine.html" title="State machine class.">StateMachine</a> class is a class to realize a state machine.</p>
<p>Example: ActiveObject assumes to be an active object that has the state machine. There are three states such as INACTIVE, ACTIVE and ERROR state, and if you want to define Entry or Exit action, this class will realize as follows: </p>
<pre>
 class ActiveObject 
 {  
 public: 
   enum MyState { INACTIVE, ACTIVE, ERROR }; 
   typedef States&lt;MyState&gt; MyStates;</pre><pre>   ActiveObject() 
     : m_sm(3) 
   { 
     m_sm.setNOP(&amp;ActiveObject::nullAction); 
     m_sm.setListener(this);</pre><pre>     m_sm.setExitAction(INACTIVE, &amp;ActiveObject::inactiveExit); 
       : 
     m_sm.setPostDoAction(ERROR, &amp;ActiveObject::errorPostDo); 
     m_sm.setTransitionAction(&amp;ActiveObject:transition); 
   };</pre><pre>   bool nullAction(MyStates st) {}; 
   bool inactiveExit(MyStates st) {}; 
     : 
   bool errorPostDo(MyStates st) {}; 
   bool transition(MyStates st) {};</pre><pre> private: 
   StateMachine&lt;MyState, bool, ActiveObject&gt; m_sm; 
 }; 
 </pre><p> If you want to give a class to some states, you must implement the class to satisfy the following conditions: </p>
<ol>
<li>
You must define states by enum. </li>
<li>
Template arguments of <a class="el" href="classRTC__Utils_1_1StateMachine.html" title="State machine class.">StateMachine</a> must be &lt;type of state(MyState), listener object, state holder，callback function&gt; </li>
<li>
Constructor arguments of <a class="el" href="classRTC__Utils_1_1StateMachine.html" title="State machine class.">StateMachine</a> must be the number of the states. </li>
<li>
You must set the following action functions as a function of (Return _function_name_(States)) <ol>
<li>
You must define a function that does not do anything and give with setNOP. </li>
<li>
You must set actions to each state by set(Entry|PreDo|Do|PostDo|Exit)Action. </li>
<li>
You should set actions at the state transition by <a class="el" href="classRTC__Utils_1_1StateMachine.html#a1b18262bc0c7fa8cae25dffd567a0806" title="Set state transition action function.">setTransitionAction()</a>. </li>
</ol>
</li>
<li>
You must implement action at the transition based on given states, such as current state, next state and previous state. </li>
<li>
You should change states by <a class="el" href="classRTC__Utils_1_1StateMachine.html#a43b923b77e7e4d3562a83880c488197d" title="Transit State.">goTo()</a> and check the state by isIn(state). </li>
<li>
<a class="el" href="classRTC__Utils_1_1StateMachine.html#a43b923b77e7e4d3562a83880c488197d" title="Transit State.">goTo()</a> is a function that sets next state forcibly, therefore, to determine the next state, you must get current state and implement that logic. </li>
</ol>
<p>In this class, you can define the following five actions for one state: </p>
<ul>
<li>
Entry action </li>
<li>
PreDo action </li>
<li>
Do action </li>
<li>
PostDo action </li>
<li>
Exit action </li>
</ul>
<p>Transition action is an action invoked at the transition between any states, and you must define its behavior.</p>
<p>This class executes each action according to the following timing.</p>
<ul>
<li>
<p class="startli">If the state is changed and transits(A-&gt;B) state,<br/>
 (A:Exit)-&gt;|(state update:A-&gt;B)-&gt;(B:Entry)-&gt;(B:PreDo)-&gt;(B:Do)-&gt;(B:PostDo)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the state is not changed and remains B state, (| shows a step's break) (B(n-1):PostDo)-&gt;|(B(n):PreDo)-&gt;(B(n):Do)-&gt;(B(n):PostDo)-&gt;|(B(n+1):PreDo) PreDo, Do and PostDo are executed over and over again.</p>
<p class="endli"></p>
</li>
<li>
If the state transits to itself<br/>
 (B(n-1):PostDo)-&gt;(B(n-1):Exit)-&gt;|(B(n):Entry)-&gt;(B(n):PreDo) <br/>
 Once Exit is invoked, Entry is executed, and then the same operation described above will be done from here on. </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>State</em>&nbsp;</td><td>Type of the state </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Listener</em>&nbsp;</td><td>Listener object for action </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>States</em>&nbsp;</td><td>State holder </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Callback function for action</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>0.4.0 </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acca3c5b3e35ae468bde803fd0975f074"></a><!-- doxytag: member="RTC_Utils::StateMachine::StateMachine" ref="acca3c5b3e35ae468bde803fd0975f074" args="(int num_of_state)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html">StateMachine</a> </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_of_state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>Constructor</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_of_state</em>&nbsp;</td><td>Number of states in the state machine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26c9f468d0188e47d891b984f8cd761d"></a><!-- doxytag: member="RTC_Utils::StateMachine::~StateMachine" ref="a26c9f468d0188e47d891b984f8cd761d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::~<a class="el" href="classRTC__Utils_1_1StateMachine.html">StateMachine</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1a768beb5bc5ec5a0e828d0e006d8003"></a><!-- doxytag: member="RTC_Utils::StateMachine::getState" ref="a1a768beb5bc5ec5a0e828d0e006d8003" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">State <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::getState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get current state. </p>
<p>Get current state.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current state </dd></dl>

</div>
</div>
<a class="anchor" id="af665f3b667caa54e29dc59a6d5b16d4c"></a><!-- doxytag: member="RTC_Utils::StateMachine::getStates" ref="af665f3b667caa54e29dc59a6d5b16d4c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">States <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::getStates </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get states. </p>
<p>Get state information. Get the current state, the previous state and the next state to be expected to transfer.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>State information </dd></dl>

</div>
</div>
<a class="anchor" id="a43b923b77e7e4d3562a83880c488197d"></a><!-- doxytag: member="RTC_Utils::StateMachine::goTo" ref="a43b923b77e7e4d3562a83880c488197d" args="(State state)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::goTo </td>
          <td>(</td>
          <td class="paramtype">State&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transit State. </p>
<p>Transit to the specified state. This function sets the next state forcibly. Therefore, to determine the next state, users must get current state and implement that logic. If transit destination is the same as the current state, flag of self-transition will be set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>State of the transition destination </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="PeriodicExecutionContext_8h_source.html#l01137">RTC::PeriodicExecutionContext::DFP&lt; OpenRTM::DataFlowComponent_var &gt;::on_activated()</a>, <a class="el" href="PeriodicExecutionContext_8h_source.html#l01274">RTC::PeriodicExecutionContext::DFP&lt; OpenRTM::DataFlowComponent_var &gt;::on_execute()</a>, <a class="el" href="PeriodicExecutionContext_8h_source.html#l01239">RTC::PeriodicExecutionContext::DFP&lt; OpenRTM::DataFlowComponent_var &gt;::on_reset()</a>, and <a class="el" href="PeriodicExecutionContext_8h_source.html#l01309">RTC::PeriodicExecutionContext::DFP&lt; OpenRTM::DataFlowComponent_var &gt;::on_state_update()</a>.</p>

</div>
</div>
<a class="anchor" id="a6338403cf745c61423e310a8b481b9df"></a><!-- doxytag: member="RTC_Utils::StateMachine::isIn" ref="a6338403cf745c61423e310a8b481b9df" args="(State state)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::isIn </td>
          <td>(</td>
          <td class="paramtype">State&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check current state. </p>
<p>Check whether current state matches the state specified by argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Target state for the check</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Check state result </dd></dl>

</div>
</div>
<a class="anchor" id="a40da53fd17393b10e4b89b9a63ba1332"></a><!-- doxytag: member="RTC_Utils::StateMachine::setDoAction" ref="a40da53fd17393b10e4b89b9a63ba1332" args="(State state, Callback call_back)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::setDoAction </td>
          <td>(</td>
          <td class="paramtype">State&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname"> <em>call_back</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Do action function. </p>
<p>Set callback function for Do action that is executed in each state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Target state for the set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>call_back</em>&nbsp;</td><td>Callback function for Do action</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Action execution result </dd></dl>

</div>
</div>
<a class="anchor" id="a611cd79fa4c9257159de08011e7e6509"></a><!-- doxytag: member="RTC_Utils::StateMachine::setEntryAction" ref="a611cd79fa4c9257159de08011e7e6509" args="(State state, Callback call_back)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::setEntryAction </td>
          <td>(</td>
          <td class="paramtype">State&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname"> <em>call_back</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Entry action function. </p>
<p>Set callback function for Entry action that is executed when entering in each state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Target state for the set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>call_back</em>&nbsp;</td><td>Callback function for Entry action</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Action execution result </dd></dl>

</div>
</div>
<a class="anchor" id="ac308579215117b100ba31c38c31d580a"></a><!-- doxytag: member="RTC_Utils::StateMachine::setExitAction" ref="ac308579215117b100ba31c38c31d580a" args="(State state, Callback call_back)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::setExitAction </td>
          <td>(</td>
          <td class="paramtype">State&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname"> <em>call_back</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Exit action function. </p>
<p>Set callback function for Exit action that is executed in each state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Target state for the set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>call_back</em>&nbsp;</td><td>Callback function for Exit action</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Action execution result </dd></dl>

</div>
</div>
<a class="anchor" id="afa4701917d4d6ec2a70f78397519f1f9"></a><!-- doxytag: member="RTC_Utils::StateMachine::setListener" ref="afa4701917d4d6ec2a70f78397519f1f9" args="(Listener *listener)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::setListener </td>
          <td>(</td>
          <td class="paramtype">Listener *&nbsp;</td>
          <td class="paramname"> <em>listener</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Listener Object. </p>
<p>Set Listener Object invoked when various actions are executed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>Listener object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d232546cd076ffbb0860a612e582416"></a><!-- doxytag: member="RTC_Utils::StateMachine::setNOP" ref="a0d232546cd076ffbb0860a612e582416" args="(Callback call_back)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::setNOP </td>
          <td>(</td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname"> <em>call_back</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set NOP function. </p>
<p>Set NOP function that does not do anything</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>call_back</em>&nbsp;</td><td>Callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99b23364ce99c4473f3a149383e7230f"></a><!-- doxytag: member="RTC_Utils::StateMachine::setNullFunc" ref="a99b23364ce99c4473f3a149383e7230f" args="(Callback *s, Callback nullfunc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::setNullFunc </td>
          <td>(</td>
          <td class="paramtype">Callback *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname"> <em>nullfunc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set NOP function. </p>
<p>Set NOP function (function to do nothing).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Callback function for setting </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nullfunc</em>&nbsp;</td><td>Callback function (NOP function) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad4ee723ecbd2f5c97b358336574c26c"></a><!-- doxytag: member="RTC_Utils::StateMachine::setPostDoAction" ref="aad4ee723ecbd2f5c97b358336574c26c" args="(State state, Callback call_back)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::setPostDoAction </td>
          <td>(</td>
          <td class="paramtype">State&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname"> <em>call_back</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set PostDo action function. </p>
<p>Set callback function for PostDo action that is executed in each state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Target state for the set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>call_back</em>&nbsp;</td><td>Callback function for PostDo action</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Action execution result </dd></dl>

</div>
</div>
<a class="anchor" id="a7bdcc53df08ccb0fa7fb31472613b2fe"></a><!-- doxytag: member="RTC_Utils::StateMachine::setPreDoAction" ref="a7bdcc53df08ccb0fa7fb31472613b2fe" args="(State state, Callback call_back)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::setPreDoAction </td>
          <td>(</td>
          <td class="paramtype">State&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname"> <em>call_back</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set PreDo action function. </p>
<p>Set callback function for PreDo action that is executed in each state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Target state for the set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>call_back</em>&nbsp;</td><td>Callback function for PreDo action</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Action execution result </dd></dl>

</div>
</div>
<a class="anchor" id="a5501ddabd4b93f4e7043708e2de26781"></a><!-- doxytag: member="RTC_Utils::StateMachine::setStartState" ref="a5501ddabd4b93f4e7043708e2de26781" args="(States states)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::setStartState </td>
          <td>(</td>
          <td class="paramtype">States&nbsp;</td>
          <td class="paramname"> <em>states</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the initial state. </p>
<p>Set the initial state of the state machine.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>states</em>&nbsp;</td><td>Initial state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b18262bc0c7fa8cae25dffd567a0806"></a><!-- doxytag: member="RTC_Utils::StateMachine::setTransitionAction" ref="a1b18262bc0c7fa8cae25dffd567a0806" args="(Callback call_back)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::setTransitionAction </td>
          <td>(</td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname"> <em>call_back</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set state transition action function. </p>
<p>Set callback function for State transition action that is executed when transiting to the state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>call_back</em>&nbsp;</td><td>Callback function for State transition</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Action execution result </dd></dl>

</div>
</div>
<a class="anchor" id="af979deaf6160e247a6a6e3027f31c83b"></a><!-- doxytag: member="RTC_Utils::StateMachine::worker" ref="af979deaf6160e247a6a6e3027f31c83b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::worker </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Worker function. </p>
<p>This is a worker function of the state machine. Execute the invocation of each action at actual state transition and the state transition occurrence. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a86145d8ddee737f186fe019dc84de243"></a><!-- doxytag: member="RTC_Utils::StateMachine::m_do" ref="a86145d8ddee737f186fe019dc84de243" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Callback* <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html#a86145d8ddee737f186fe019dc84de243">m_do</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function for Do action. </p>

</div>
</div>
<a class="anchor" id="a728fe8f596c77e326bc356b274144bb5"></a><!-- doxytag: member="RTC_Utils::StateMachine::m_entry" ref="a728fe8f596c77e326bc356b274144bb5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Callback* <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html#a728fe8f596c77e326bc356b274144bb5">m_entry</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function for Entry action. </p>

</div>
</div>
<a class="anchor" id="a75fb6776bd228a8005eda56e49a33373"></a><!-- doxytag: member="RTC_Utils::StateMachine::m_exit" ref="a75fb6776bd228a8005eda56e49a33373" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Callback* <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html#a75fb6776bd228a8005eda56e49a33373">m_exit</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function for Exit action. </p>

</div>
</div>
<a class="anchor" id="a25f2e293e773fe5c4ffdd49fb343f734"></a><!-- doxytag: member="RTC_Utils::StateMachine::m_listener" ref="a25f2e293e773fe5c4ffdd49fb343f734" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Listener* <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html#a25f2e293e773fe5c4ffdd49fb343f734">m_listener</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function for listener. </p>

</div>
</div>
<a class="anchor" id="aedd1306b007958b49a248d07578214b3"></a><!-- doxytag: member="RTC_Utils::StateMachine::m_mutex" ref="aedd1306b007958b49a248d07578214b3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoil_1_1Mutex.html">Mutex</a> <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html#aedd1306b007958b49a248d07578214b3">m_mutex</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2503583562749e18c43ca48c6066d9f4"></a><!-- doxytag: member="RTC_Utils::StateMachine::m_num" ref="a2503583562749e18c43ca48c6066d9f4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html#a2503583562749e18c43ca48c6066d9f4">m_num</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of state. </p>

</div>
</div>
<a class="anchor" id="ac90335d93cc0c173335b130dd91a33e4"></a><!-- doxytag: member="RTC_Utils::StateMachine::m_postdo" ref="ac90335d93cc0c173335b130dd91a33e4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Callback* <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html#ac90335d93cc0c173335b130dd91a33e4">m_postdo</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function for PostDo action. </p>

</div>
</div>
<a class="anchor" id="a687b8b8abab11fb696555fa861240f30"></a><!-- doxytag: member="RTC_Utils::StateMachine::m_predo" ref="a687b8b8abab11fb696555fa861240f30" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Callback* <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html#a687b8b8abab11fb696555fa861240f30">m_predo</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function for PreDo action. </p>

</div>
</div>
<a class="anchor" id="aa02af266af8b8e0abf6609abede2a323"></a><!-- doxytag: member="RTC_Utils::StateMachine::m_selftrans" ref="aa02af266af8b8e0abf6609abede2a323" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html#aa02af266af8b8e0abf6609abede2a323">m_selftrans</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a29e2692dc448060388da12e0a029cfad"></a><!-- doxytag: member="RTC_Utils::StateMachine::m_states" ref="a29e2692dc448060388da12e0a029cfad" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">States <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html#a29e2692dc448060388da12e0a029cfad">m_states</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Current state information. </p>

</div>
</div>
<a class="anchor" id="aa292b9b27cf14ea9b82b2ad8b8ddc49d"></a><!-- doxytag: member="RTC_Utils::StateMachine::m_transit" ref="aa292b9b27cf14ea9b82b2ad8b8ddc49d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class State, class Listener, class States = StateHolder&lt;State&gt;, class Callback = void (Listener::*)(const States&amp; states)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Callback <a class="el" href="classRTC__Utils_1_1StateMachine.html">RTC_Utils::StateMachine</a>&lt; State, Listener, States, Callback &gt;::<a class="el" href="classRTC__Utils_1_1StateMachine.html#aa292b9b27cf14ea9b82b2ad8b8ddc49d">m_transit</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback function for State transition action. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu May 24 23:25:23 2012 for OpenRTM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
