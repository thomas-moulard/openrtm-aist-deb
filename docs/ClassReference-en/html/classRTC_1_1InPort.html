<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenRTM: RTC::InPort&lt; DataType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceRTC.html">RTC</a>::<a class="el" href="classRTC_1_1InPort.html">InPort</a>
  </div>
</div>
<div class="contents">
<h1>RTC::InPort&lt; DataType &gt; Class Template Reference</h1><!-- doxytag: class="RTC::InPort" --><!-- doxytag: inherits="RTC::InPortBase" -->
<p><a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> template class.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="InPort_8h_source.html">InPort.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTC::InPort&lt; DataType &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="classRTC_1_1InPort.png" usemap="#RTC::InPort&lt; DataType &gt;_map" alt=""/>
  <map id="RTC::InPort&lt; DataType &gt;_map" name="RTC::InPort&lt; DataType &gt;_map">
<area href="classRTC_1_1InPortBase.html" alt="RTC::InPortBase" shape="rect" coords="81,56,234,80"/>
<area href="classRTC_1_1PortBase.html" alt="RTC::PortBase" shape="rect" coords="0,0,153,24"/>
<area href="classRTC_1_1DataPortStatus.html" alt="RTC::DataPortStatus" shape="rect" coords="163,0,316,24"/>
</map>
 </div>
</div>

<p><a href="classRTC_1_1InPort-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DATAPORTSTATUS_ENUM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1InPort.html#a8450177baa07f202144fbba039f4b827">InPort</a> (const char *name, DataType &amp;value, int bufsize=64, bool read_block=false, bool write_block=false, int read_timeout=0, int write_timeout=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constructor.  <a href="#a8450177baa07f202144fbba039f4b827"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1InPort.html#a42532e8164d15bbb92cdce9ff5f3baf8">~InPort</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a42532e8164d15bbb92cdce9ff5f3baf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1InPort.html#ae8e026ff3e775a211022e2a108d8a672">name</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get port name.  <a href="#ae8e026ff3e775a211022e2a108d8a672"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1InPort.html#af3030dcf08e4951924407df3e71fc123">isNew</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the data is newest.  <a href="#af3030dcf08e4951924407df3e71fc123"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1InPort.html#a0bf0a0b180a60961fa7559aa54af57ca">isEmpty</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the data is newest.  <a href="#a0bf0a0b180a60961fa7559aa54af57ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1InPort.html#a1b6e58e0c821b46148266ddfd0b9bd54">read</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Readout the value from DataPort.  <a href="#a1b6e58e0c821b46148266ddfd0b9bd54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1InPort.html#ad1efc0019d9a62030106552ad4f4436d">update</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the newly value to type-T variable which is bound to InPort's buffer.  <a href="#ad1efc0019d9a62030106552ad4f4436d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1InPort.html#a44cc1bb1cf583f7b88578e39c04b5ea5">operator&gt;&gt;</a> (DataType &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the newly value data in <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> to type-T variable.  <a href="#a44cc1bb1cf583f7b88578e39c04b5ea5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1InPort.html#a93fe41858e1e8dd7dee71b64703b7343">setOnRead</a> (<a class="el" href="structRTC_1_1OnRead.html">OnRead</a>&lt; DataType &gt; *on_read)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set callback when data is read from the <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> buffer.  <a href="#a93fe41858e1e8dd7dee71b64703b7343"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1InPort.html#af799d52ed11a670ef56da9a2b2a9e7ff">setOnReadConvert</a> (<a class="el" href="structRTC_1_1OnReadConvert.html">OnReadConvert</a>&lt; DataType &gt; *on_rconvert)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set callback when data is readout to the <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> buffer.  <a href="#af799d52ed11a670ef56da9a2b2a9e7ff"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class DataType&gt;<br/>
 class RTC::InPort&lt; DataType &gt;</h3>

<p><a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> template class. </p>
<p>This is a template class that implements <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a>. &lt;T&gt; is the type defined in BasicDataType.idl and must be the structure which has both Time type tm and type-T data as a member. <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> has a ring buffer internally, and stores the received data externally in this buffer one by one. The size of ring buffer can be specified according to the argument of constructor, though the default size is 64. Unread data and data which is already read are managed with the flag, and the data can be handled by the <a class="el" href="classRTC_1_1InPort.html#af3030dcf08e4951924407df3e71fc123" title="Check whether the data is newest.">isNew()</a>, write(), <a class="el" href="classRTC_1_1InPort.html#a1b6e58e0c821b46148266ddfd0b9bd54" title="Readout the value from DataPort.">read()</a>, isFull() and <a class="el" href="classRTC_1_1InPort.html#a0bf0a0b180a60961fa7559aa54af57ca" title="Check whether the data is newest.">isEmpty()</a> method etc.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>0.2.0 </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8450177baa07f202144fbba039f4b827"></a><!-- doxytag: member="RTC::InPort::InPort" ref="a8450177baa07f202144fbba039f4b827" args="(const char *name, DataType &amp;value, int bufsize=64, bool read_block=false, bool write_block=false, int read_timeout=0, int write_timeout=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DATAPORTSTATUS_ENUM <a class="el" href="classRTC_1_1InPort.html">RTC::InPort</a>&lt; DataType &gt;::<a class="el" href="classRTC_1_1InPort.html">InPort</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bufsize</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>read_block</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>write_block</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>read_timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>write_timeout</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A constructor. </p>
<p>constructor. This is bound to type-T variable given as a parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>A name of the <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a>. This name is referred by InPortBase::name(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>type-T variable that is bound to this <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufsize</em>&nbsp;</td><td>Buffer length of internal ring buffer of <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> (The default value:64) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>read_block</em>&nbsp;</td><td>Flag of reading block. When there are not unread data at reading data, set whether to block data until receiving the next data. (The default value:false) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>write_block</em>&nbsp;</td><td>Flag of writing block. If the buffer was full at writing data, set whether to block data until the buffer has space. (The default value:false) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>read_timeout</em>&nbsp;</td><td>Data reading timeout time (millisecond) when not specifying read blocking. (The default value:0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>write_timeout</em>&nbsp;</td><td>Data writing timeout time (millisecond) when not specifying writing block. (The default value:0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42532e8164d15bbb92cdce9ff5f3baf8"></a><!-- doxytag: member="RTC::InPort::~InPort" ref="a42532e8164d15bbb92cdce9ff5f3baf8" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRTC_1_1InPort.html">RTC::InPort</a>&lt; DataType &gt;::~<a class="el" href="classRTC_1_1InPort.html">InPort</a> </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Destructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0bf0a0b180a60961fa7559aa54af57ca"></a><!-- doxytag: member="RTC::InPort::isEmpty" ref="a0bf0a0b180a60961fa7559aa54af57ca" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classRTC_1_1InPort.html">RTC::InPort</a>&lt; DataType &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the data is newest. </p>
<p>Check whether the data stored at a current buffer position is newest.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Newest data check result ( true:Newest data. Data has not been readout yet. false:Past data．Data has already been readout.) </dd></dl>

<p>References <a class="el" href="InPortBase_8h_source.html#l00853">RTC::InPortBase::m_connectors</a>, <a class="el" href="PortBase_8h_source.html#l02088">RTC::PortBase::m_connectorsMutex</a>, <a class="el" href="SystemLogger_8h_source.html#l00488">RTC_DEBUG</a>, and <a class="el" href="SystemLogger_8h_source.html#l00510">RTC_TRACE</a>.</p>

</div>
</div>
<a class="anchor" id="af3030dcf08e4951924407df3e71fc123"></a><!-- doxytag: member="RTC::InPort::isNew" ref="af3030dcf08e4951924407df3e71fc123" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classRTC_1_1InPort.html">RTC::InPort</a>&lt; DataType &gt;::isNew </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the data is newest. </p>
<p>Check whether the data stored at a current buffer position is newest.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Newest data check result ( true:Newest data. Data has not been readout yet. false:Past data．Data has already been readout.) </dd></dl>

<p>References <a class="el" href="InPortBase_8h_source.html#l00853">RTC::InPortBase::m_connectors</a>, <a class="el" href="PortBase_8h_source.html#l02088">RTC::PortBase::m_connectorsMutex</a>, <a class="el" href="SystemLogger_8h_source.html#l00488">RTC_DEBUG</a>, and <a class="el" href="SystemLogger_8h_source.html#l00510">RTC_TRACE</a>.</p>

</div>
</div>
<a class="anchor" id="ae8e026ff3e775a211022e2a108d8a672"></a><!-- doxytag: member="RTC::InPort::name" ref="ae8e026ff3e775a211022e2a108d8a672" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classRTC_1_1InPort.html">RTC::InPort</a>&lt; DataType &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get port name. </p>
<p>Get port name.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The port name </dd></dl>

</div>
</div>
<a class="anchor" id="a44cc1bb1cf583f7b88578e39c04b5ea5"></a><!-- doxytag: member="RTC::InPort::operator&gt;&gt;" ref="a44cc1bb1cf583f7b88578e39c04b5ea5" args="(DataType &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRTC_1_1InPort.html">RTC::InPort</a>&lt; DataType &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">DataType &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the newly value data in <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> to type-T variable. </p>
<p>Read the newly data set in <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> and set to specified data variable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The type-T variable to read from InPort's buffer </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="InPort_8h_source.html#l00378">RTC::InPort&lt; DataType &gt;::read()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b6e58e0c821b46148266ddfd0b9bd54"></a><!-- doxytag: member="RTC::InPort::read" ref="a1b6e58e0c821b46148266ddfd0b9bd54" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRTC_1_1InPort.html">RTC::InPort</a>&lt; DataType &gt;::read </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Readout the value from DataPort. </p>
<p>Readout the value from DataPort</p>
<ul>
<li>When Callback functor <a class="el" href="structRTC_1_1OnRead.html" title="Callback abstract class on read().">OnRead</a> is already set, <a class="el" href="structRTC_1_1OnRead.html" title="Callback abstract class on read().">OnRead</a> will be invoked before reading from the buffer held by DataPort.</li>
<li>When the buffer held by DataPort can detect the underflow, and when it detected the underflow at reading, callback functor OnUnderflow will be invoked.</li>
<li>When callback functor <a class="el" href="structRTC_1_1OnReadConvert.html" title="Data convert callback abstract class on read().">OnReadConvert</a> is already set, the return value of operator() of <a class="el" href="structRTC_1_1OnReadConvert.html" title="Data convert callback abstract class on read().">OnReadConvert</a> will be the return value of <a class="el" href="classRTC_1_1InPort.html#a1b6e58e0c821b46148266ddfd0b9bd54" title="Readout the value from DataPort.">read()</a>.</li>
<li>When timeout of reading is already set by setReadTimeout(), it waits for only timeout time until the state of the buffer underflow is reset, and if OnUnderflow is already set, this will be invoked to return.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Readout result (Successful:true, Failed:false) </dd></dl>

<p>Implements <a class="el" href="classRTC_1_1InPortBase.html#a448e72f4d6d7890c4fb6add7d86d04b5">RTC::InPortBase</a>.</p>

<p>References <a class="el" href="DataPortStatus_8h_source.html#l00149">RTC::DataPortStatus::BUFFER_EMPTY</a>, <a class="el" href="DataPortStatus_8h_source.html#l00150">RTC::DataPortStatus::BUFFER_TIMEOUT</a>, <a class="el" href="InPortBase_8h_source.html#l00853">RTC::InPortBase::m_connectors</a>, <a class="el" href="PortBase_8h_source.html#l02088">RTC::PortBase::m_connectorsMutex</a>, <a class="el" href="DataPortStatus_8h_source.html#l00145">RTC::DataPortStatus::PORT_OK</a>, <a class="el" href="SystemLogger_8h_source.html#l00488">RTC_DEBUG</a>, <a class="el" href="SystemLogger_8h_source.html#l00422">RTC_ERROR</a>, <a class="el" href="SystemLogger_8h_source.html#l00510">RTC_TRACE</a>, and <a class="el" href="SystemLogger_8h_source.html#l00444">RTC_WARN</a>.</p>

<p>Referenced by <a class="el" href="InPort_8h_source.html#l00477">RTC::InPort&lt; DataType &gt;::operator&gt;&gt;()</a>, and <a class="el" href="InPort_8h_source.html#l00452">RTC::InPort&lt; DataType &gt;::update()</a>.</p>

</div>
</div>
<a class="anchor" id="a93fe41858e1e8dd7dee71b64703b7343"></a><!-- doxytag: member="RTC::InPort::setOnRead" ref="a93fe41858e1e8dd7dee71b64703b7343" args="(OnRead&lt; DataType &gt; *on_read)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRTC_1_1InPort.html">RTC::InPort</a>&lt; DataType &gt;::setOnRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRTC_1_1OnRead.html">OnRead</a>&lt; DataType &gt; *&nbsp;</td>
          <td class="paramname"> <em>on_read</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set callback when data is read from the <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> buffer. </p>
<p>Set the callback object that is invoked right before data is read from the InPort's buffer</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on_read</em>&nbsp;</td><td><a class="el" href="structRTC_1_1OnRead.html" title="Callback abstract class on read().">OnRead</a>&lt;DataType&gt; type object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af799d52ed11a670ef56da9a2b2a9e7ff"></a><!-- doxytag: member="RTC::InPort::setOnReadConvert" ref="af799d52ed11a670ef56da9a2b2a9e7ff" args="(OnReadConvert&lt; DataType &gt; *on_rconvert)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRTC_1_1InPort.html">RTC::InPort</a>&lt; DataType &gt;::setOnReadConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRTC_1_1OnReadConvert.html">OnReadConvert</a>&lt; DataType &gt; *&nbsp;</td>
          <td class="paramname"> <em>on_rconvert</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set callback when data is readout to the <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> buffer. </p>
<p>Set the callback object that is invoked when data is readout to the InPort's buffer. The return value of callback object is the return result of the <a class="el" href="classRTC_1_1InPort.html#a1b6e58e0c821b46148266ddfd0b9bd54" title="Readout the value from DataPort.">read()</a> method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on_rconvert</em>&nbsp;</td><td><a class="el" href="structRTC_1_1OnReadConvert.html" title="Data convert callback abstract class on read().">OnReadConvert</a>&lt;DataType&gt; type object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1efc0019d9a62030106552ad4f4436d"></a><!-- doxytag: member="RTC::InPort::update" ref="ad1efc0019d9a62030106552ad4f4436d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classRTC_1_1InPort.html">RTC::InPort</a>&lt; DataType &gt;::update </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the newly value to type-T variable which is bound to InPort's buffer. </p>
<p>Read the newly value to type-T data which is bound to InPort's buffer. The type-T variable must be bound to <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> in constructor. Since this method assumes to be used for polymorphic, its argument and the return value do not depend on type. </p>

<p>References <a class="el" href="InPort_8h_source.html#l00378">RTC::InPort&lt; DataType &gt;::read()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu May 24 23:25:22 2012 for OpenRTM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
