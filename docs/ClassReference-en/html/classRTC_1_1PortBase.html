<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenRTM: RTC::PortBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceRTC.html">RTC</a>::<a class="el" href="classRTC_1_1PortBase.html">PortBase</a>
  </div>
</div>
<div class="contents">
<h1>RTC::PortBase Class Reference</h1><!-- doxytag: class="RTC::PortBase" -->
<p>Port base class.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PortBase_8h_source.html">PortBase.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTC::PortBase:</div>
<div class="dynsection">
 <div class="center">
  <img src="classRTC_1_1PortBase.png" usemap="#RTC::PortBase_map" alt=""/>
  <map id="RTC::PortBase_map" name="RTC::PortBase_map">
<area href="classRTC_1_1CorbaPort.html" alt="RTC::CorbaPort" shape="rect" coords="0,56,163,80"/>
<area href="classRTC_1_1InPortBase.html" alt="RTC::InPortBase" shape="rect" coords="173,56,336,80"/>
<area href="classRTC_1_1OutPortBase.html" alt="RTC::OutPortBase" shape="rect" coords="346,56,509,80"/>
<area href="classRTC_1_1InPort.html" alt="RTC::InPort&lt; DataType &gt;" shape="rect" coords="173,112,336,136"/>
<area href="classRTC_1_1OutPort.html" alt="RTC::OutPort&lt; DataType &gt;" shape="rect" coords="346,112,509,136"/>
</map>
 </div>
</div>

<p><a href="classRTC_1_1PortBase-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTC_1_1PortBase_1_1find__conn__id.html">find_conn_id</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor to find a ConnectorProfile named id.  <a href="structRTC_1_1PortBase_1_1find__conn__id.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTC_1_1PortBase_1_1find__interface.html">find_interface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor to find interface from name and polarity.  <a href="structRTC_1_1PortBase_1_1find__interface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRTC_1_1PortBase_1_1find__port__ref.html">find_port_ref</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor to find the object reference that is identical port_ref.  <a href="structRTC_1_1PortBase_1_1find__port__ref.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a778ffb56398a68f1a9254773a4bbc0b7">PortBase</a> (const char *name=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a778ffb56398a68f1a9254773a4bbc0b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#acc3ed2687a796b80c0b29d170e2e27aa">~PortBase</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#acc3ed2687a796b80c0b29d170e2e27aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PortProfile *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#ae38441f66c19863e383f461de846a062">get_port_profile</a> ()  throw (CORBA::SystemException)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[CORBA interface] Get the PortProfile of the Port  <a href="#ae38441f66c19863e383f461de846a062"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const PortProfile &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#af76274dad83b880e0773c0f109c8deb8">getPortProfile</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the PortProfile of the Port.  <a href="#af76274dad83b880e0773c0f109c8deb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ConnectorProfileList *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a00e8e5597add78a8e8f044a98ff60cfd">get_connector_profiles</a> ()  throw (CORBA::SystemException)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[CORBA interface] Get the ConnectorProfileList of the Port  <a href="#a00e8e5597add78a8e8f044a98ff60cfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ConnectorProfile *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a66847c611f82d14894356fd122315c06">get_connector_profile</a> (const char *connector_id)  throw (CORBA::SystemException)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[CORBA interface] Get the ConnectorProfile  <a href="#a66847c611f82d14894356fd122315c06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462">connect</a> (ConnectorProfile &amp;connector_profile)  throw (CORBA::SystemException)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[CORBA interface] Connect the Port  <a href="#a139d07d2e94f7e793aedf4aa24b92462"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766">notify_connect</a> (ConnectorProfile &amp;connector_profile)  throw (CORBA::SystemException)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[CORBA interface] Notify the Ports connection  <a href="#a9bcc3c981a6649f37f3ad7eac31e5766"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a1ac6bea826249d3b2b9cb09d475e54f8">disconnect</a> (const char *connector_id)  throw (CORBA::SystemException)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[CORBA interface] Disconnect the Port  <a href="#a1ac6bea826249d3b2b9cb09d475e54f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca">notify_disconnect</a> (const char *connector_id)  throw (CORBA::SystemException)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[CORBA interface] Notify the Ports disconnection  <a href="#ae78bb7882d22bca794bd0faa78452aca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a2464e0184036a389c4083625d7a1435f">disconnect_all</a> ()  throw (CORBA::SystemException)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[CORBA interface] Disconnect the All Ports  <a href="#a2464e0184036a389c4083625d7a1435f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#ad779347bae007555968dda9e78004e34">activateInterfaces</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activate all Port interfaces.  <a href="#ad779347bae007555968dda9e78004e34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a8dfb8a33b92b9fc9b6c070df2def633f">deactivateInterfaces</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deactivate all Port interfaces.  <a href="#a8dfb8a33b92b9fc9b6c070df2def633f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a4429d9d48ba72f621ed446b50bdf9043">setName</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name of this Port.  <a href="#a4429d9d48ba72f621ed446b50bdf9043"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a2897e7321c60684612cb286954e84653">getName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this Port.  <a href="#a2897e7321c60684612cb286954e84653"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const PortProfile &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#ab5ab1328c5d5be82e5a213f6900c4eb8">getProfile</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the PortProfile of the Port.  <a href="#ab5ab1328c5d5be82e5a213f6900c4eb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a710706ff630c6502e3de6cf5dd302c83">setPortRef</a> (PortService_ptr port_ref)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the object reference of this Port.  <a href="#a710706ff630c6502e3de6cf5dd302c83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PortService_ptr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a2b8a9dad7bcb51557471a7d034631d25">getPortRef</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the object reference of this Port.  <a href="#a2b8a9dad7bcb51557471a7d034631d25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a1431e933c50b7f31df6446051ca4b3fe">setOwner</a> (RTObject_ptr owner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the owner RTObject of the Port.  <a href="#a1431e933c50b7f31df6446051ca4b3fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#affce1efdd04a8b66af5238ee435a5b2b">setOnPublishInterfaces</a> (<a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *on_publish)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting callback called on publish interfaces.  <a href="#affce1efdd04a8b66af5238ee435a5b2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#ac9783d3edef34a7f5c5cef910b4fa33a">setOnSubscribeInterfaces</a> (<a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *on_subscribe)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting callback called on publish interfaces.  <a href="#ac9783d3edef34a7f5c5cef910b4fa33a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a7c97305b47e95f96dffaee6871db9b5d">setOnConnected</a> (<a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *on_connected)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting callback called on connection established.  <a href="#a7c97305b47e95f96dffaee6871db9b5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#aff023d4b2faa7d161b7c91ef9273a705">setOnUnsubscribeInterfaces</a> (<a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *on_subscribe)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting callback called on unsubscribe interfaces.  <a href="#aff023d4b2faa7d161b7c91ef9273a705"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a8f26ec4ff60e7728a09cbd34a6a2ca33">setOnDisconnected</a> (<a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *on_disconnected)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting callback called on disconnected.  <a href="#a8f26ec4ff60e7728a09cbd34a6a2ca33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#aa7797b53a5199aecb86ebd6e11da9a6e">setOnConnectionLost</a> (<a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *on_connection_lost)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting callback called on connection lost.  <a href="#aa7797b53a5199aecb86ebd6e11da9a6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#aa0fca5f8b8ce5503439f21c7e940227b">setPortConnectListenerHolder</a> (<a class="el" href="classRTC_1_1PortConnectListeners.html">PortConnectListeners</a> *portconnListeners)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting <a class="el" href="classRTC_1_1PortConnectListener.html" title="PortConnectListener class.">PortConnectListener</a> holder.  <a href="#aa0fca5f8b8ce5503439f21c7e940227b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcoil_1_1Guard.html">coil::Guard</a>&lt; <a class="el" href="classcoil_1_1Mutex.html">coil::Mutex</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#afed27d51e39b7ad3a0cd0a7c80cc6b53">Guard</a></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#acf31878c5912f56c122aaa2310e182de">publishInterfaces</a> (ConnectorProfile &amp;connector_profile)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish interface information.  <a href="#acf31878c5912f56c122aaa2310e182de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#acd7017c12c99c59c191d1269b40a7423">connectNext</a> (ConnectorProfile &amp;connector_profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> of the next Port.  <a href="#acd7017c12c99c59c191d1269b40a7423"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a4eeddc35a698e4020e7ba96627dcde3b">disconnectNext</a> (ConnectorProfile &amp;connector_profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> of the next Port.  <a href="#a4eeddc35a698e4020e7ba96627dcde3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#afce755069836c1ee637784e2a9e5a02b">subscribeInterfaces</a> (const ConnectorProfile &amp;connector_profile)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish interface information.  <a href="#afce755069836c1ee637784e2a9e5a02b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a8a843a387e99d4d4daa6e829eb1db569">unsubscribeInterfaces</a> (const ConnectorProfile &amp;connector_profile)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnect interface connection.  <a href="#a8a843a387e99d4d4daa6e829eb1db569"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a9dce68b24fdfbf13f835f6b8b83f2282">setConnectionLimit</a> (int limit_value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximum number of connections.  <a href="#a9dce68b24fdfbf13f835f6b8b83f2282"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#afa9ee9900b247eb705c1dd27a6f6efe8">_publishInterfaces</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Publish interface information.  <a href="#afa9ee9900b247eb705c1dd27a6f6efe8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a9829b707373bd30160e1b6df7244f0bc">isEmptyId</a> (const ConnectorProfile &amp;connector_profile) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether connector_id of ConnectorProfile is empty.  <a href="#a9829b707373bd30160e1b6df7244f0bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a6ff52fee873d00a96b0e33880397af44">getUUID</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the UUID.  <a href="#a6ff52fee873d00a96b0e33880397af44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a7d8fb06825e17568567786987bd00fbb">setUUID</a> (ConnectorProfile &amp;connector_profile) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate and set the UUID to the ConnectorProfile.  <a href="#a7d8fb06825e17568567786987bd00fbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a15653054a5bd4e0559e0c3edec3b11d3">isExistingConnId</a> (const char *id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the given id exists in stored ConnectorProfiles.  <a href="#a15653054a5bd4e0559e0c3edec3b11d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ConnectorProfile&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a271f7e306eec757069326b493c6838e2">findConnProfile</a> (const char *id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find ConnectorProfile with id.  <a href="#a271f7e306eec757069326b493c6838e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CORBA::Long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a7626d1f676704dfa3d3f173c7964cc7c">findConnProfileIndex</a> (const char *id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find ConnectorProfile with id.  <a href="#a7626d1f676704dfa3d3f173c7964cc7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#aaaa8155f6dd891d0a4b77e6f6c55c97b">updateConnectorProfile</a> (const ConnectorProfile &amp;connector_profile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append or update the ConnectorProfile list.  <a href="#aaaa8155f6dd891d0a4b77e6f6c55c97b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a3803219dc15de9ebb9bf096a82cfb383">eraseConnectorProfile</a> (const char *id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the ConnectorProfile.  <a href="#a3803219dc15de9ebb9bf096a82cfb383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a91146c0cd579ad2d67b0bca8c7a437bf">appendInterface</a> (const char *name, const char *type_name, PortInterfacePolarity pol)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an interface to the PortInterfaceProfile.  <a href="#a91146c0cd579ad2d67b0bca8c7a437bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#aef670f0cfa3bafbc0207e0ea63f7a083">deleteInterface</a> (const char *name, PortInterfacePolarity pol)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the interface registration from the PortInterfaceProfile.  <a href="#aef670f0cfa3bafbc0207e0ea63f7a083"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#ab6548d7c61ff22a34b418ae4964177ba">addProperty</a> (const char *key, ValueType value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add NameValue data to PortProfile's properties.  <a href="#ab6548d7c61ff22a34b418ae4964177ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#ac6d94d956a43f47157c2aacd0be1da4c">appendProperty</a> (const char *key, const char *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append NameValue data to PortProfile's properties.  <a href="#ac6d94d956a43f47157c2aacd0be1da4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#aa9e0697ef8a7138cdf30ab756ecc9242">updateConnectors</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnect ports that doesn't exist.  <a href="#aa9e0697ef8a7138cdf30ab756ecc9242"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#abfc03f49c63f915a307ce34fed244439">checkPorts</a> (::RTC::PortServiceList &amp;ports)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Existence of ports.  <a href="#abfc03f49c63f915a307ce34fed244439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a6c5fc09077478e84e9c26405bf7be4d1">onNotifyConnect</a> (const char *portname, RTC::ConnectorProfile &amp;profile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a1f81e3d706c34c0ff4ad77445629c1f3">onNotifyDisconnect</a> (const char *portname, RTC::ConnectorProfile &amp;profile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#af3a2ec35c3c1eb1c59dc6634069d04a0">onUnsubscribeInterfaces</a> (const char *portname, RTC::ConnectorProfile &amp;profile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a70dd82c8188309bb79d64907d638542f">onPublishInterfaces</a> (const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a1f1b927fc26a71d74b7f82be3c57fe54">onConnectNextport</a> (const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#af5c66c1f389171c0fad73e26a74a619e">onSubscribeInterfaces</a> (const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a454895298d71c2f046db0071a7e2b1ae">onConnected</a> (const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a2558aed0af62dca59972bafa8be29617">onDisconnectNextport</a> (const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a6c8539e8b047205a3cdf5b34c27a246e">onDisconnected</a> (const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTC_1_1Logger.html">Logger</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#ab111ca721c706fe5e93da18705ace90e">rtclog</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classRTC_1_1Logger.html" title="Logger class.">Logger</a> stream.  <a href="#ab111ca721c706fe5e93da18705ace90e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PortProfile&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a02b8a89853dc64600f9301a87f50138a">m_profile</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PortProfile of the Port.  <a href="#a02b8a89853dc64600f9301a87f50138a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RTC::PortService_var&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a6add3c9750060e44acaec9e70a78ed92">m_objref</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object Reference of the Port.  <a href="#a6add3c9750060e44acaec9e70a78ed92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoil_1_1Mutex.html">coil::Mutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a2ee84ba32ff8423c318798dea9814642">m_profile_mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex of PortProfile.  <a href="#a2ee84ba32ff8423c318798dea9814642"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcoil_1_1Mutex.html">coil::Mutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#acbdf425104a21619d4c887e415e045c8">m_connectorsMutex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a6f33c6161ecc2b00babcb3a18c7438df">m_ownerInstanceName</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instance name.  <a href="#a6f33c6161ecc2b00babcb3a18c7438df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a0c568d0d7ffd5c5dfbf7cdfbd27e22c9">m_connectionLimit</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum number of connections.  <a href="#a0c568d0d7ffd5c5dfbf7cdfbd27e22c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a85b7308b6911a14bbd26f62106fa2986">m_onPublishInterfaces</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback functor objects.  <a href="#a85b7308b6911a14bbd26f62106fa2986"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a63ef15306f2d4d66b9570f11d8715057">m_onSubscribeInterfaces</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback functor objects.  <a href="#a63ef15306f2d4d66b9570f11d8715057"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a52852f17f0978a6a639fcf6c8a8a71b6">m_onConnected</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback functor objects.  <a href="#a52852f17f0978a6a639fcf6c8a8a71b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a34d4ada2f1dfcebec2adc85e5aea484a">m_onUnsubscribeInterfaces</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback functor objects.  <a href="#a34d4ada2f1dfcebec2adc85e5aea484a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#ac1ddf7686081da5a663f9109b7ad740f">m_onDisconnected</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback functor objects.  <a href="#ac1ddf7686081da5a663f9109b7ad740f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a2d7cfeb11e8bccae7702badef6d384f4">m_onConnectionLost</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback functor objects.  <a href="#a2d7cfeb11e8bccae7702badef6d384f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRTC_1_1PortConnectListeners.html">PortConnectListeners</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PortBase.html#a0e9ebbf6f53845b48d087240eeb8656f">m_portconnListeners</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classRTC_1_1PortConnectListener.html" title="PortConnectListener class.">PortConnectListener</a> holder.  <a href="#a0e9ebbf6f53845b48d087240eeb8656f"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Port base class. </p>
<p>This class is a base class of RTC::Port. RTC::Port inherits a concept of RT-Component, and can be regarded as almost the same as it. In the concept of RT-Component, Port is attached to the component, can mediate interaction between other components and usually is associated with some interfaces. Component can provide or require interface for outside via Port, and the Port plays a role to manage the connection. </p>
<p>Concrete class of Port assumes to be usually created at the same time that RT-Component's instance is created, be registerd to RT-Component after provided and required interfaces are registerd, and function as accessible Port from outside. </p>
<p>RTC::Port provides the following operations as CORBA interface:</p>
<ul>
<li><a class="el" href="classRTC_1_1PortBase.html#ae38441f66c19863e383f461de846a062" title="[CORBA interface] Get the PortProfile of the Port">get_port_profile()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#a00e8e5597add78a8e8f044a98ff60cfd" title="[CORBA interface] Get the ConnectorProfileList of the Port">get_connector_profiles()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#a66847c611f82d14894356fd122315c06" title="[CORBA interface] Get the ConnectorProfile">get_connector_profile()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#a1ac6bea826249d3b2b9cb09d475e54f8" title="[CORBA interface] Disconnect the Port">disconnect()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#a2464e0184036a389c4083625d7a1435f" title="[CORBA interface] Disconnect the All Ports">disconnect_all()</a></li>
</ul>
<p>This class provides implementations of these operations. </p>
<p>In these operations, as for <a class="el" href="classRTC_1_1PortBase.html#ae38441f66c19863e383f461de846a062" title="[CORBA interface] Get the PortProfile of the Port">get_port_profile()</a>, <a class="el" href="classRTC_1_1PortBase.html#a00e8e5597add78a8e8f044a98ff60cfd" title="[CORBA interface] Get the ConnectorProfileList of the Port">get_connector_profiles()</a>, <a class="el" href="classRTC_1_1PortBase.html#a66847c611f82d14894356fd122315c06" title="[CORBA interface] Get the ConnectorProfile">get_connector_profile()</a>, <a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a>, <a class="el" href="classRTC_1_1PortBase.html#a1ac6bea826249d3b2b9cb09d475e54f8" title="[CORBA interface] Disconnect the Port">disconnect()</a> and <a class="el" href="classRTC_1_1PortBase.html#a2464e0184036a389c4083625d7a1435f" title="[CORBA interface] Disconnect the All Ports">disconnect_all()</a>, since their behaviors especially need not to be change in subclass, overriding is not recommended. </p>
<p>As for <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> and <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a>, you may have to modify behavior according to the kind of interfaces that subclass provides and requires, however it is not recommended these are overriden directly. In the section of <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> and <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> as described below, it is recommended that you modify behavior by overriding the protected function related to these functions.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>0.4.0 </dd></dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="afed27d51e39b7ad3a0cd0a7c80cc6b53"></a><!-- doxytag: member="RTC::PortBase::Guard" ref="afed27d51e39b7ad3a0cd0a7c80cc6b53" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcoil_1_1Guard.html">coil::Guard</a>&lt;<a class="el" href="classcoil_1_1Mutex.html">coil::Mutex</a>&gt; <a class="el" href="classcoil_1_1Guard.html">RTC::PortBase::Guard</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a778ffb56398a68f1a9254773a4bbc0b7"></a><!-- doxytag: member="RTC::PortBase::PortBase" ref="a778ffb56398a68f1a9254773a4bbc0b7" args="(const char *name=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTC::PortBase::PortBase </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>&quot;&quot;</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>The constructor of the ProtBase class is given the name of this Port and initialized. At the same time, the <a class="el" href="classRTC_1_1PortBase.html" title="Port base class.">PortBase</a> activates itself as CORBA object and stores its object reference to the PortProfile's port_ref member. Characters except "." can be used for the name of the port.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of Port (The default value:"") </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc3ed2687a796b80c0b29d170e2e27aa"></a><!-- doxytag: member="RTC::PortBase::~PortBase" ref="acc3ed2687a796b80c0b29d170e2e27aa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual RTC::PortBase::~PortBase </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>In the destructor, PortService CORBA object is deactivated. This function never throws exception. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afa9ee9900b247eb705c1dd27a6f6efe8"></a><!-- doxytag: member="RTC::PortBase::_publishInterfaces" ref="afa9ee9900b247eb705c1dd27a6f6efe8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::PortBase::_publishInterfaces </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Publish interface information. </p>
<p>Publish interface information.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return code of ReturnCode_t type </dd></dl>

</div>
</div>
<a class="anchor" id="ad779347bae007555968dda9e78004e34"></a><!-- doxytag: member="RTC::PortBase::activateInterfaces" ref="ad779347bae007555968dda9e78004e34" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTC::PortBase::activateInterfaces </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activate all Port interfaces. </p>
<p>This operation activate all interfaces that is registered in the ports. </p>

<p>Implemented in <a class="el" href="classRTC_1_1CorbaPort.html#a1b9efe804a293b2c38a9cbe3b5ba54a0">RTC::CorbaPort</a>, <a class="el" href="classRTC_1_1InPortBase.html#a4188e629df750498e0d3b100f51133ff">RTC::InPortBase</a>, and <a class="el" href="classRTC_1_1OutPortBase.html#a4741de18bb77db12a192055468eca8a8">RTC::OutPortBase</a>.</p>

</div>
</div>
<a class="anchor" id="ab6548d7c61ff22a34b418ae4964177ba"></a><!-- doxytag: member="RTC::PortBase::addProperty" ref="ab6548d7c61ff22a34b418ae4964177ba" args="(const char *key, ValueType value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::addProperty </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add NameValue data to PortProfile's properties. </p>
<p>Add NameValue data to PortProfile's properties. Type of additional data is specified by ValueType.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The name of properties </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of properties </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="PortBase_8h_source.html#l02070">m_profile</a>, <a class="el" href="NVUtil_8h_source.html#l00079">NVUtil::newNV()</a>, and <a class="el" href="CORBA__SeqUtil_8h_source.html#l00175">CORBA_SeqUtil::push_back()</a>.</p>

</div>
</div>
<a class="anchor" id="a91146c0cd579ad2d67b0bca8c7a437bf"></a><!-- doxytag: member="RTC::PortBase::appendInterface" ref="a91146c0cd579ad2d67b0bca8c7a437bf" args="(const char *name, const char *type_name, PortInterfacePolarity pol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTC::PortBase::appendInterface </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PortInterfacePolarity&nbsp;</td>
          <td class="paramname"> <em>pol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an interface to the PortInterfaceProfile. </p>
<p>This operation appends interface information to the PortInterfaceProfile that is owned by the Port. The given interfaces information only updates PortInterfaceProfile of PortProfile that is obtained through <a class="el" href="classRTC_1_1PortBase.html#ae38441f66c19863e383f461de846a062" title="[CORBA interface] Get the PortProfile of the Port">get_port_profile()</a>. In order to provide and require interfaces, proper functions (for example publishInterface(), subscribeInterface() and so on) should be overridden in subclasses, and these functions provide concrete interface connection and disconnection functionality.</p>
<p>The interface (instance) name have to be unique in the Port. If the given interface name is identical with stored interface name, this function returns false.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The instance name of the interface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type_name</em>&nbsp;</td><td>The type name of the interface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pol</em>&nbsp;</td><td>The interface's polarity (RTC::PROVIDED or <a class="el" href="namespaceRTC.html" title="RT-Component.">RTC</a>:REQUIRED)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false would be returned if the same name is already registered. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6d94d956a43f47157c2aacd0be1da4c"></a><!-- doxytag: member="RTC::PortBase::appendProperty" ref="ac6d94d956a43f47157c2aacd0be1da4c" args="(const char *key, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::appendProperty </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append NameValue data to PortProfile's properties. </p>
<p>Append NameValue data to PortProfile's properties. The properties which are set by this function would be referred through <a class="el" href="classRTC_1_1PortBase.html#ae38441f66c19863e383f461de846a062" title="[CORBA interface] Get the PortProfile of the Port">get_port_profile()</a> from outsides.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The name of properties </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of properties </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespaceNVUtil.html#aa481ca6c5c584b9da26d56fc2c4be67c">NVUtil::appendStringValue()</a>, and <a class="el" href="PortBase_8h_source.html#l02070">m_profile</a>.</p>

</div>
</div>
<a class="anchor" id="abfc03f49c63f915a307ce34fed244439"></a><!-- doxytag: member="RTC::PortBase::checkPorts" ref="abfc03f49c63f915a307ce34fed244439" args="(::RTC::PortServiceList &amp;ports)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTC::PortBase::checkPorts </td>
          <td>(</td>
          <td class="paramtype">::RTC::PortServiceList &amp;&nbsp;</td>
          <td class="paramname"> <em>ports</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Existence of ports. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ports</em>&nbsp;</td><td>Checked ports </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true:existent,false:non existent </dd></dl>

</div>
</div>
<a class="anchor" id="a139d07d2e94f7e793aedf4aa24b92462"></a><!-- doxytag: member="RTC::PortBase::connect" ref="a139d07d2e94f7e793aedf4aa24b92462" args="(ConnectorProfile &amp;connector_profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::PortBase::connect </td>
          <td>(</td>
          <td class="paramtype">ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (CORBA::SystemException)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>[CORBA interface] Connect the Port </p>
<p>This operation establishes connection according to the given ConnectionProfile inforamtion. This function is premised on calling from mainly application program or tools.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>To establish the connection among Ports of RT-Components, application programs must call this operation giving ConnectorProfile with valid values as an argument.</dd>
<dd>
Out of ConnectorProfile member variables, "name", "ports" and "properties" members shall be set valid data. "connector_id" shall be set as empty string value or valid string UUID value.</dd>
<dd>
ConnectorProfile::name that is connection identifier shall be any valid CORBA::string.</dd>
<dd>
ConnectorProfile::connector_id shall be set unique identifier (usually UUID is used) for all connections. Since UUID string value is usually set in the <a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a> function, caller should just set empty string. If the <a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a> is called with the same UUID as existing connection, this function returns PRECONDITION_NOT_MET error. However, in order to update the existing connection profile, the "connect()" operation with existing connector ID might be used as valid method by future extension</dd>
<dd>
ConnectorProfile::ports, which is sequence of RTC::PortService references, shall store usually two or more ports' references. As exceptions, the "connect()" operation might be called with only one reference in ConnectorProfile, in case of just getting interfaces information from the port, or connecting a special port (i.e. the peer port except RTC::PortService on CORBA).</dd>
<dd>
ConnectorProfile::properties might be used to give certain properties to the service interfaces associated with the port. The properties is a sequence variable with a pair of key string and Any type value. Although the A variable can store any type of values, it is not recommended except string.</dd>
<dd>
The following is the summary of the ConnectorProfile member to be set when this operation is called.</dd></dl>
<ul>
<li>ConnectorProfile::name: The any name of connection</li>
<li>ConnectorProfile::connector_id: Empty string</li>
<li>ConnectorProfile::ports: One or more port references</li>
<li>ConnectorProfile::properties: Properties for the interfaces</li>
</ul>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a> operation will call the first port in the sequence of the ConnectorProfile.</dd>
<dd>
"noify_connect()"s perform cascaded call to the ports stored in the ConnectorProfile::ports by order. Even if errors are raised by intermediate <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> operation, as long as ports' object references are valid, it is guaranteed that this cascaded call is completed in all the ports. If invalid or dead ports exist in the port's sequence, the ports are skipped and <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> is called for the next valid port.</dd>
<dd>
<a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a> function returns RTC_OK if all the <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> return RTC_OK. At this time the connection is completed. If <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a>s return except RTC_OK, <a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a> calls <a class="el" href="classRTC_1_1PortBase.html#a1ac6bea826249d3b2b9cb09d475e54f8" title="[CORBA interface] Disconnect the Port">disconnect()</a> operation with the connector_id to destruct the connection, and then it returns error code from <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a>.</dd>
<dd>
The ConnectorProfile argument of the <a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a> operation returns ConnectorProfile::connector_id and various information about service interfaces that is published by <a class="el" href="classRTC_1_1PortBase.html#acf31878c5912f56c122aaa2310e182de" title="Publish interface information.">publishInterfaces()</a> in the halfway ports. The <a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a> and halfway <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> functions never change ConnectorProfile::{name, ports}.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>The ConnectorProfile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ReturnCode_t The return code of ReturnCode_t type. </dd></dl>

<p>Reimplemented in <a class="el" href="classRTC_1_1InPortBase.html#ab37ad76d4270c20133b52b1bbdf3b529">RTC::InPortBase</a>, and <a class="el" href="classRTC_1_1OutPortBase.html#ab6297aece321369ebc78900962627f0d">RTC::OutPortBase</a>.</p>

</div>
</div>
<a class="anchor" id="acd7017c12c99c59c191d1269b40a7423"></a><!-- doxytag: member="RTC::PortBase::connectNext" ref="acd7017c12c99c59c191d1269b40a7423" args="(ConnectorProfile &amp;connector_profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::PortBase::connectNext </td>
          <td>(</td>
          <td class="paramtype">ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> of the next Port. </p>
<p>This operation calls the <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> of the next Port's that stored in ConnectorProfile's port_ref sequence.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>The connection profile information</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return code of ReturnCode_t type. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dfb8a33b92b9fc9b6c070df2def633f"></a><!-- doxytag: member="RTC::PortBase::deactivateInterfaces" ref="a8dfb8a33b92b9fc9b6c070df2def633f" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTC::PortBase::deactivateInterfaces </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deactivate all Port interfaces. </p>
<p>This operation deactivate all interfaces that is registered in the ports. </p>

<p>Implemented in <a class="el" href="classRTC_1_1CorbaPort.html#a4c25f8e04aa9cceff24c31ea3fec4e5b">RTC::CorbaPort</a>, <a class="el" href="classRTC_1_1InPortBase.html#a4d8bba26fce07c092ebffbab6b1aa881">RTC::InPortBase</a>, and <a class="el" href="classRTC_1_1OutPortBase.html#aa08d3ddfdf0b00398b40e76164622e43">RTC::OutPortBase</a>.</p>

</div>
</div>
<a class="anchor" id="aef670f0cfa3bafbc0207e0ea63f7a083"></a><!-- doxytag: member="RTC::PortBase::deleteInterface" ref="aef670f0cfa3bafbc0207e0ea63f7a083" args="(const char *name, PortInterfacePolarity pol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTC::PortBase::deleteInterface </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PortInterfacePolarity&nbsp;</td>
          <td class="paramname"> <em>pol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the interface registration from the PortInterfaceProfile. </p>
<p>This operation deletes interface information from the PortInterfaceProfile that is owned by the Port.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The instance name of the interface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pol</em>&nbsp;</td><td>The interface's polarity (RTC::PROVIDED or <a class="el" href="namespaceRTC.html" title="RT-Component.">RTC</a>:REQUIRED)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Delete processing result of interface. false would be returned if the given name is not registered. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ac6bea826249d3b2b9cb09d475e54f8"></a><!-- doxytag: member="RTC::PortBase::disconnect" ref="a1ac6bea826249d3b2b9cb09d475e54f8" args="(const char *connector_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::PortBase::disconnect </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>connector_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (CORBA::SystemException)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>[CORBA interface] Disconnect the Port </p>
<p>This operation destroys connection between this port and the peer port according to given connector_id. Usually connector_id should be a UUID string that is unique in the system. And the connection, which is established by <a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a>/notify_connect() functions, is identified by the ConnectorProfile::connector_id.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>connector_id shall be a character string which is same with ID of at least one of the ConnectorProfiles stored in this port. If ConnectorProfile that has same ID with the given connector_id does not exist in the list of ConnectorProfile, this operation returns BAD_PARAMTER error.</dd>
<dd>
ConnectorProfile::ports that is same ID with given connector_id shall store the valid ports' references.</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><a class="el" href="classRTC_1_1PortBase.html#a1ac6bea826249d3b2b9cb09d475e54f8" title="[CORBA interface] Disconnect the Port">disconnect()</a> function invokes the <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> for the port that is stored in the first of the ConnectorProfile::ports. If <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> call fails for the first port, It tries on calling "notify_disconnect()" in order for ports stored in ConnectorProfile::ports until the operation call is succeeded. If <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> succeeded for at least one port, it returns return code from <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a>. If none of <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> call succeeded, it returns RTC_ERROR error.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_id</em>&nbsp;</td><td>The ID of the ConnectorProfile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ReturnCode_t The return code of ReturnCode_t type. </dd></dl>

<p>Referenced by <a class="el" href="OutPort_8h_source.html#l00203">RTC::OutPort&lt; DataType &gt;::write()</a>.</p>

</div>
</div>
<a class="anchor" id="a2464e0184036a389c4083625d7a1435f"></a><!-- doxytag: member="RTC::PortBase::disconnect_all" ref="a2464e0184036a389c4083625d7a1435f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::PortBase::disconnect_all </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (CORBA::SystemException)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>[CORBA interface] Disconnect the All Ports </p>
<p>This operation destroys all connections associated with this Port.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ReturnCode_t The return code of ReturnCode_t type. </dd></dl>

</div>
</div>
<a class="anchor" id="a4eeddc35a698e4020e7ba96627dcde3b"></a><!-- doxytag: member="RTC::PortBase::disconnectNext" ref="a4eeddc35a698e4020e7ba96627dcde3b" args="(ConnectorProfile &amp;connector_profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::PortBase::disconnectNext </td>
          <td>(</td>
          <td class="paramtype">ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> of the next Port. </p>
<p>This operation calls the <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> of the next Port's that stored in ConnectorProfile's port_ref sequence.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>The connection profile information</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return code of ReturnCode_t type. </dd></dl>

</div>
</div>
<a class="anchor" id="a3803219dc15de9ebb9bf096a82cfb383"></a><!-- doxytag: member="RTC::PortBase::eraseConnectorProfile" ref="a3803219dc15de9ebb9bf096a82cfb383" args="(const char *id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTC::PortBase::eraseConnectorProfile </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the ConnectorProfile. </p>
<p>This operation deletes a ConnectorProfile specified by id from ConnectorProfileList owned by PortProfile of this Port.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The id of the ConnectorProfile to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true would be returned if it deleted correctly. false woluld be returned if specified ConnectorProfile cannot be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a271f7e306eec757069326b493c6838e2"></a><!-- doxytag: member="RTC::PortBase::findConnProfile" ref="a271f7e306eec757069326b493c6838e2" args="(const char *id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConnectorProfile RTC::PortBase::findConnProfile </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find ConnectorProfile with id. </p>
<p>This operation returns ConnectorProfile with the given id from Port's ConnectorProfiles' list. If the ConnectorProfile with connector id that is identical with the given id does not exist, empty ConnectorProfile is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>the connector_id to be searched in Port's ConnectorProfiles</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CoonectorProfile with connector_id </dd></dl>

<p>Referenced by <a class="el" href="OutPort_8h_source.html#l00203">RTC::OutPort&lt; DataType &gt;::write()</a>.</p>

</div>
</div>
<a class="anchor" id="a7626d1f676704dfa3d3f173c7964cc7c"></a><!-- doxytag: member="RTC::PortBase::findConnProfileIndex" ref="a7626d1f676704dfa3d3f173c7964cc7c" args="(const char *id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CORBA::Long RTC::PortBase::findConnProfileIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find ConnectorProfile with id. </p>
<p>This operation returns ConnectorProfile with the given id from Port's ConnectorProfiles' list. If the ConnectorProfile with connector id that is identical with the given id does not exist, -1 is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>the connector_id to be searched</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of ConnectorProfile of the Port </dd></dl>

</div>
</div>
<a class="anchor" id="a66847c611f82d14894356fd122315c06"></a><!-- doxytag: member="RTC::PortBase::get_connector_profile" ref="a66847c611f82d14894356fd122315c06" args="(const char *connector_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ConnectorProfile* RTC::PortBase::get_connector_profile </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>connector_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (CORBA::SystemException)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>[CORBA interface] Get the ConnectorProfile </p>
<p>This operation returns the ConnectorProfiles specified connector_id. Since this function is CORBA operation, callers have responsibility to destruction of the returned ConnectorProfile object according to the CORBA memory management rules.</p>
<p>If ConnectorProfile with specified connector_id is not included, empty ConnectorProfile is returned.</p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>This function never changes the state of the object.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_id</em>&nbsp;</td><td>ID of the ConnectorProfile </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the ConnectorProfile identified by the connector_id </dd></dl>

</div>
</div>
<a class="anchor" id="a00e8e5597add78a8e8f044a98ff60cfd"></a><!-- doxytag: member="RTC::PortBase::get_connector_profiles" ref="a00e8e5597add78a8e8f044a98ff60cfd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ConnectorProfileList* RTC::PortBase::get_connector_profiles </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (CORBA::SystemException)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>[CORBA interface] Get the ConnectorProfileList of the Port </p>
<p>This operation returns a list of the ConnectorProfiles of the Port. Since this function is CORBA operation, callers have responsibility to destruction of the returned ConnectorProfileList object according to the CORBA memory management rules.</p>
<p>ConnectorProfile includes the connection information that describes relation between (among) Ports, and Ports exchange the ConnectionProfile on connection process and hold the same information in every Port. ConnectionProfile has the following members:</p>
<ul>
<li>name [string type] The name of the connection.</li>
<li>connector_id [string type] Unique identifier.</li>
<li>ports [Port sequnce] The sequence of Port's object reference that are related the connection.</li>
<li>properties [NVList type] The other properties.</li>
</ul>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>This function never changes the state of the object.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ConnectorProfileList of the Port </dd></dl>

</div>
</div>
<a class="anchor" id="ae38441f66c19863e383f461de846a062"></a><!-- doxytag: member="RTC::PortBase::get_port_profile" ref="ae38441f66c19863e383f461de846a062" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PortProfile* RTC::PortBase::get_port_profile </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (CORBA::SystemException)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>[CORBA interface] Get the PortProfile of the Port </p>
<p>This operation returns the PortProfile of the Port. Since this function is CORBA operation, callers have responsibility to destruction of the returned PortProfile object according to the CORBA memory management rules.</p>
<p>PortProfile struct has the following members:</p>
<ul>
<li>name [string type] The name of the Port.</li>
<li>interfaces [PortInterfaceProfileList type] The sequence of PortInterfaceProfile owned by the Port</li>
<li>port_ref [Port Object type] The object reference of the Port.</li>
<li>connector_profile [ConnectorProfileList type] The sequence of ConnectorProfile owned by the Port.</li>
<li>owner [RTObject Object type] The object reference of RTObject that is owner of the Port.</li>
<li>properties [NVList type] The other properties.</li>
</ul>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>This function never changes the state of the object.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PortProfile of the Port </dd></dl>

</div>
</div>
<a class="anchor" id="a2897e7321c60684612cb286954e84653"></a><!-- doxytag: member="RTC::PortBase::getName" ref="a2897e7321c60684612cb286954e84653" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* RTC::PortBase::getName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of this Port. </p>
<p>This operation returns the name of this Port.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of this Port. </dd></dl>

</div>
</div>
<a class="anchor" id="af76274dad83b880e0773c0f109c8deb8"></a><!-- doxytag: member="RTC::PortBase::getPortProfile" ref="af76274dad83b880e0773c0f109c8deb8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PortProfile&amp; RTC::PortBase::getPortProfile </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the PortProfile of the Port. </p>
<p>This function is a const function that returns a const reference of the PortProfile stored in this Port.</p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>This function never changes the state of the object.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PortProfile </dd></dl>

</div>
</div>
<a class="anchor" id="a2b8a9dad7bcb51557471a7d034631d25"></a><!-- doxytag: member="RTC::PortBase::getPortRef" ref="a2b8a9dad7bcb51557471a7d034631d25" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PortService_ptr RTC::PortBase::getPortRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the object reference of this Port. </p>
<p>This operation returns the object reference that is stored in the Port's PortProfile.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The object reference of this Port. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5ab1328c5d5be82e5a213f6900c4eb8"></a><!-- doxytag: member="RTC::PortBase::getProfile" ref="ab5ab1328c5d5be82e5a213f6900c4eb8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PortProfile&amp; RTC::PortBase::getProfile </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the PortProfile of the Port. </p>
<p>This operation returns const reference of the PortProfile.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>PortProfile of the Port </dd></dl>

</div>
</div>
<a class="anchor" id="a6ff52fee873d00a96b0e33880397af44"></a><!-- doxytag: member="RTC::PortBase::getUUID" ref="a6ff52fee873d00a96b0e33880397af44" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string RTC::PortBase::getUUID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate the UUID. </p>
<p>This operation generates UUID.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>uuid </dd></dl>

</div>
</div>
<a class="anchor" id="a9829b707373bd30160e1b6df7244f0bc"></a><!-- doxytag: member="RTC::PortBase::isEmptyId" ref="a9829b707373bd30160e1b6df7244f0bc" args="(const ConnectorProfile &amp;connector_profile) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTC::PortBase::isEmptyId </td>
          <td>(</td>
          <td class="paramtype">const ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether connector_id of ConnectorProfile is empty. </p>
<p>Check whether connector_id of specified ConnectorProfile is empty.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>Target ConnectorProfile for the check</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If the given ConnectorProfile's connector_id is empty string, it returns true. </dd></dl>

</div>
</div>
<a class="anchor" id="a15653054a5bd4e0559e0c3edec3b11d3"></a><!-- doxytag: member="RTC::PortBase::isExistingConnId" ref="a15653054a5bd4e0559e0c3edec3b11d3" args="(const char *id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RTC::PortBase::isExistingConnId </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the given id exists in stored ConnectorProfiles. </p>
<p>This operation returns boolean whether the given id exists in the Port's ConnectorProfiles.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>connector_id to be find in Port's ConnectorProfiles</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>id exestance resutl </dd></dl>

</div>
</div>
<a class="anchor" id="a9bcc3c981a6649f37f3ad7eac31e5766"></a><!-- doxytag: member="RTC::PortBase::notify_connect" ref="a9bcc3c981a6649f37f3ad7eac31e5766" args="(ConnectorProfile &amp;connector_profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::PortBase::notify_connect </td>
          <td>(</td>
          <td class="paramtype">ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (CORBA::SystemException)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>[CORBA interface] Notify the Ports connection </p>
<p>This operation is usually called from other ports' <a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a> or <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> operations when connection between ports is established. This function is not premised on calling from other functions or application programs.</p>
<p>According to the template method pattern, the <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> calls "publishInterfaces()" and "subsctiveInterfaces()" functions, which are premised on implementing in the subclasses. The processing sequence is as follows.</p>
<ul>
<li><a class="el" href="classRTC_1_1PortBase.html#acf31878c5912f56c122aaa2310e182de" title="Publish interface information.">publishInterfaces()</a>: Publishing interface information</li>
<li><a class="el" href="classRTC_1_1PortBase.html#acd7017c12c99c59c191d1269b40a7423" title="Call notify_connect() of the next Port.">connectNext()</a>: Calling <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> of the next port</li>
<li><a class="el" href="classRTC_1_1PortBase.html#afce755069836c1ee637784e2a9e5a02b" title="Publish interface information.">subscribeInterfaces()</a>: Subscribing interface information</li>
<li>Storing connection profile</li>
</ul>
<p>According to the order of port's references stored in the ConnectorProfile::ports, publishing interface information to all the ports and subscription interface information from all the ports is performed by "notify_connect()"s. This cascaded call never aborts in the halfway operations, and calling sequence shall be completed for all the ports.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> calls <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> for the port's reference that is stored in next of this port's reference in the sequence of the ConnectorProfile::ports. Therefore the reference of this port shall be stored in the ConnectorProfile::ports. If this port's reference is not stored in the sequence, BAD_PARAMETER error will be returned, except the return code is overwritten by other operations.</dd>
<dd>
UUID shall be set to ConnectorProfile::connector_id as a unique identifier when this operation is called. Usually, connector_id is given by a <a class="el" href="classRTC_1_1PortBase.html#a139d07d2e94f7e793aedf4aa24b92462" title="[CORBA interface] Connect the Port">connect()</a> function and, the behavior is undefined in the case of a null character.</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>ConnectorProfile::name, ConnectorProfile::connector_id, ConnectorProfile::ports are invariant, and they are never rewritten by <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> operations.</dd>
<dd>
In order to transfer interface information to other ports, interface property information is stored into the ConnectorProfile::properties.</dd>
<dd>
At the end of <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> operation for the first port stored in the ConnectorProfile::ports sequence, the related ports' <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> invocations complete. Even if errors are raised at the halfway of <a class="el" href="classRTC_1_1PortBase.html#acf31878c5912f56c122aaa2310e182de" title="Publish interface information.">publishInterfaces()</a>, <a class="el" href="classRTC_1_1PortBase.html#acd7017c12c99c59c191d1269b40a7423" title="Call notify_connect() of the next Port.">connectNext()</a>, <a class="el" href="classRTC_1_1PortBase.html#afce755069836c1ee637784e2a9e5a02b" title="Publish interface information.">subscribeInterfaces()</a> and storing process of ConnectorProfile, error codes are saved and the first error is returned.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>The ConnectorProfile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ReturnCode_t The return code of ReturnCode_t type. </dd></dl>

</div>
</div>
<a class="anchor" id="ae78bb7882d22bca794bd0faa78452aca"></a><!-- doxytag: member="RTC::PortBase::notify_disconnect" ref="ae78bb7882d22bca794bd0faa78452aca" args="(const char *connector_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::PortBase::notify_disconnect </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>connector_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (CORBA::SystemException)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>[CORBA interface] Notify the Ports disconnection </p>
<p>This operation is invoked between Ports internally when the connection is destroied. Generally it is not premised on calling from application programs or <a class="el" href="namespaceRTC.html" title="RT-Component.">RTC</a> objects except Port object.</p>
<p>According to the template method pattern, the <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> calls unsubsctiveInterfaces() function, which are premised on implementing in the subclasses. The processing sequence is as follows.</p>
<ul>
<li>Searching ConnectorProfile</li>
<li>Calling <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> for the next port</li>
<li>Unsubscribing interfaces</li>
<li>Deleting ConnectorProfile</li>
</ul>
<p><a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> notifies disconnection to all the ports by cascaded call to the stored ports in the ConnectorProfile::ports in order.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The port shall store the ConnectorProfile having same id with connector_id.</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>If ConnectorProfile of same ID with connector_id does not exist, it returns BAD_PARAMETER error.</dd>
<dd>
For the cascaded call, this operation calls noify_disconnect() for the port that is stored in the next of this port in the ConnectorProfile::ports. If the operation call raises exception for some failure, it tries to call <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> and skips until the operation succeeded. If none of operation call succeeded, it returns RTC_ERROR.</dd>
<dd>
At the end of <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> operation for the first port stored in the ConnectorProfile::ports sequence, the related ports' <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> invocations complete.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_id</em>&nbsp;</td><td>The ID of the ConnectorProfile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ReturnCode_t The return code of ReturnCode_t type. </dd></dl>

</div>
</div>
<a class="anchor" id="a454895298d71c2f046db0071a7e2b1ae"></a><!-- doxytag: member="RTC::PortBase::onConnected" ref="a454895298d71c2f046db0071a7e2b1ae" args="(const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::onConnected </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTC::ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReturnCode_t&nbsp;</td>
          <td class="paramname"> <em>ret</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="PortBase_8h_source.html#l02211">m_portconnListeners</a>, and <a class="el" href="PortConnectListener_8h_source.html#l00166">RTC::ON_CONNECTED</a>.</p>

</div>
</div>
<a class="anchor" id="a1f1b927fc26a71d74b7f82be3c57fe54"></a><!-- doxytag: member="RTC::PortBase::onConnectNextport" ref="a1f1b927fc26a71d74b7f82be3c57fe54" args="(const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::onConnectNextport </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTC::ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReturnCode_t&nbsp;</td>
          <td class="paramname"> <em>ret</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="PortBase_8h_source.html#l02211">m_portconnListeners</a>, and <a class="el" href="PortConnectListener_8h_source.html#l00164">RTC::ON_CONNECT_NEXTPORT</a>.</p>

</div>
</div>
<a class="anchor" id="a6c8539e8b047205a3cdf5b34c27a246e"></a><!-- doxytag: member="RTC::PortBase::onDisconnected" ref="a6c8539e8b047205a3cdf5b34c27a246e" args="(const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::onDisconnected </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTC::ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReturnCode_t&nbsp;</td>
          <td class="paramname"> <em>ret</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="PortBase_8h_source.html#l02211">m_portconnListeners</a>, and <a class="el" href="PortConnectListener_8h_source.html#l00168">RTC::ON_DISCONNECTED</a>.</p>

</div>
</div>
<a class="anchor" id="a2558aed0af62dca59972bafa8be29617"></a><!-- doxytag: member="RTC::PortBase::onDisconnectNextport" ref="a2558aed0af62dca59972bafa8be29617" args="(const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::onDisconnectNextport </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTC::ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReturnCode_t&nbsp;</td>
          <td class="paramname"> <em>ret</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="PortBase_8h_source.html#l02211">m_portconnListeners</a>, and <a class="el" href="PortConnectListener_8h_source.html#l00167">RTC::ON_DISCONNECT_NEXT</a>.</p>

</div>
</div>
<a class="anchor" id="a6c5fc09077478e84e9c26405bf7be4d1"></a><!-- doxytag: member="RTC::PortBase::onNotifyConnect" ref="a6c5fc09077478e84e9c26405bf7be4d1" args="(const char *portname, RTC::ConnectorProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::onNotifyConnect </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTC::ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="PortBase_8h_source.html#l02211">m_portconnListeners</a>, and <a class="el" href="PortConnectListener_8h_source.html#l00051">RTC::ON_NOTIFY_CONNECT</a>.</p>

</div>
</div>
<a class="anchor" id="a1f81e3d706c34c0ff4ad77445629c1f3"></a><!-- doxytag: member="RTC::PortBase::onNotifyDisconnect" ref="a1f81e3d706c34c0ff4ad77445629c1f3" args="(const char *portname, RTC::ConnectorProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::onNotifyDisconnect </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTC::ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="PortBase_8h_source.html#l02211">m_portconnListeners</a>, and <a class="el" href="PortConnectListener_8h_source.html#l00052">RTC::ON_NOTIFY_DISCONNECT</a>.</p>

</div>
</div>
<a class="anchor" id="a70dd82c8188309bb79d64907d638542f"></a><!-- doxytag: member="RTC::PortBase::onPublishInterfaces" ref="a70dd82c8188309bb79d64907d638542f" args="(const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::onPublishInterfaces </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTC::ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReturnCode_t&nbsp;</td>
          <td class="paramname"> <em>ret</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="PortBase_8h_source.html#l02211">m_portconnListeners</a>, and <a class="el" href="PortConnectListener_8h_source.html#l00163">RTC::ON_PUBLISH_INTERFACES</a>.</p>

</div>
</div>
<a class="anchor" id="af5c66c1f389171c0fad73e26a74a619e"></a><!-- doxytag: member="RTC::PortBase::onSubscribeInterfaces" ref="af5c66c1f389171c0fad73e26a74a619e" args="(const char *portname, RTC::ConnectorProfile &amp;profile, ReturnCode_t ret)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::onSubscribeInterfaces </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTC::ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReturnCode_t&nbsp;</td>
          <td class="paramname"> <em>ret</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="PortBase_8h_source.html#l02211">m_portconnListeners</a>, and <a class="el" href="PortConnectListener_8h_source.html#l00165">RTC::ON_SUBSCRIBE_INTERFACES</a>.</p>

</div>
</div>
<a class="anchor" id="af3a2ec35c3c1eb1c59dc6634069d04a0"></a><!-- doxytag: member="RTC::PortBase::onUnsubscribeInterfaces" ref="af3a2ec35c3c1eb1c59dc6634069d04a0" args="(const char *portname, RTC::ConnectorProfile &amp;profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::onUnsubscribeInterfaces </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTC::ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="PortBase_8h_source.html#l02211">m_portconnListeners</a>, and <a class="el" href="PortConnectListener_8h_source.html#l00053">RTC::ON_UNSUBSCRIBE_INTERFACES</a>.</p>

</div>
</div>
<a class="anchor" id="acf31878c5912f56c122aaa2310e182de"></a><!-- doxytag: member="RTC::PortBase::publishInterfaces" ref="acf31878c5912f56c122aaa2310e182de" args="(ConnectorProfile &amp;connector_profile)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::PortBase::publishInterfaces </td>
          <td>(</td>
          <td class="paramtype">ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Publish interface information. </p>
<p>This operation is pure virutal function that would be called at the beginning of the <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> process sequence. In the <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a>, the following methods would be called in order.</p>
<ul>
<li><a class="el" href="classRTC_1_1PortBase.html#acf31878c5912f56c122aaa2310e182de" title="Publish interface information.">publishInterfaces()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#acd7017c12c99c59c191d1269b40a7423" title="Call notify_connect() of the next Port.">connectNext()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#afce755069836c1ee637784e2a9e5a02b" title="Publish interface information.">subscribeInterfaces()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#aaaa8155f6dd891d0a4b77e6f6c55c97b" title="Append or update the ConnectorProfile list.">updateConnectorProfile()</a></li>
</ul>
<p>In the concrete Port, this method should be overridden. This method processes the given ConnectorProfile argument and if the given parameter is invalid, it would return error code of ReturnCode_t. Usually, <a class="el" href="classRTC_1_1PortBase.html#acf31878c5912f56c122aaa2310e182de" title="Publish interface information.">publishInterfaces()</a> method should set interfaces information owned by this Port, and publish it to the other Ports. <br/>
 When this method is called, other Ports' interfaces information may not be completed. Therefore, the process to obtain other Port's interfaces information should be done in the <a class="el" href="classRTC_1_1PortBase.html#afce755069836c1ee637784e2a9e5a02b" title="Publish interface information.">subscribeInterfaces()</a> method. <br/>
 This operation should create the new connection for the new connector_id, and should update the connection for the existing connection_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>The connection profile information</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return code of ReturnCode_t type. </dd></dl>

<p>Implemented in <a class="el" href="classRTC_1_1CorbaPort.html#a71aa316c3324369c4462193d10a5d098">RTC::CorbaPort</a>, <a class="el" href="classRTC_1_1InPortBase.html#ad836b599b157efb1a31ec61999015986">RTC::InPortBase</a>, and <a class="el" href="classRTC_1_1OutPortBase.html#ab71eea8c300820c2dd21dd13a61f6e0f">RTC::OutPortBase</a>.</p>

</div>
</div>
<a class="anchor" id="a9dce68b24fdfbf13f835f6b8b83f2282"></a><!-- doxytag: member="RTC::PortBase::setConnectionLimit" ref="a9dce68b24fdfbf13f835f6b8b83f2282" args="(int limit_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTC::PortBase::setConnectionLimit </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>limit_value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the maximum number of connections. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>limit_value</em>&nbsp;</td><td>The maximum number of connections </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4429d9d48ba72f621ed446b50bdf9043"></a><!-- doxytag: member="RTC::PortBase::setName" ref="a4429d9d48ba72f621ed446b50bdf9043" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::setName </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the name of this Port. </p>
<p>This operation sets the name of this Port. The given Port's name is applied to Port's PortProfile.name.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of this Port. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c97305b47e95f96dffaee6871db9b5d"></a><!-- doxytag: member="RTC::PortBase::setOnConnected" ref="a7c97305b47e95f96dffaee6871db9b5d" args="(ConnectionCallback *on_connected)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::setOnConnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>on_connected</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting callback called on connection established. </p>
<p>This operation sets a functor that is called when connection between ports established.</p>
<p>Since the ownership of the callback functor object is owned by the caller, it has the responsibility of object destruction.</p>
<p>The callback functor is called only when <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> function successfully returns. In case of error, the functor will not be called.</p>
<p>Since this functor is called with ConnectorProfile argument that is same as out-parameter of <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> function, you can get all the information of published interfaces of related ports in the connection. Although by using this functor, you can modify ConnectorProfile argument for out-paramter of <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a>, the modification should be done carefully for fear of causing connection inconsistency.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on_subscribe</em>&nbsp;</td><td>a pointer to ConnectionCallback's subclasses </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7797b53a5199aecb86ebd6e11da9a6e"></a><!-- doxytag: member="RTC::PortBase::setOnConnectionLost" ref="aa7797b53a5199aecb86ebd6e11da9a6e" args="(ConnectionCallback *on_connection_lost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::setOnConnectionLost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>on_connection_lost</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting callback called on connection lost. </p>
<p>This operation sets a functor that is called when connection of this port does lost.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on_connection_lost</em>&nbsp;</td><td>a pointer to ConnectionCallback's subclasses </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f26ec4ff60e7728a09cbd34a6a2ca33"></a><!-- doxytag: member="RTC::PortBase::setOnDisconnected" ref="a8f26ec4ff60e7728a09cbd34a6a2ca33" args="(ConnectionCallback *on_disconnected)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::setOnDisconnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>on_disconnected</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting callback called on disconnected. </p>
<p>This operation sets a functor that is called when connection between ports is destructed.</p>
<p>Since the ownership of the callback functor object is owned by the caller, it has the responsibility of object destruction.</p>
<p>The callback functor is called just before <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> that is disconnection execution function returns.</p>
<p>This functor is called with argument of corresponding ConnectorProfile. Since this ConnectorProfile will be destructed after calling this functor, modifications never affect others.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on_disconnected</em>&nbsp;</td><td>a pointer to ConnectionCallback's subclasses </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affce1efdd04a8b66af5238ee435a5b2b"></a><!-- doxytag: member="RTC::PortBase::setOnPublishInterfaces" ref="affce1efdd04a8b66af5238ee435a5b2b" args="(ConnectionCallback *on_publish)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::setOnPublishInterfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>on_publish</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting callback called on publish interfaces. </p>
<p>This operation sets a functor that is called after publishing interfaces process when connecting between ports.</p>
<p>Since the ownership of the callback functor object is owned by the caller, it has the responsibility of object destruction.</p>
<p>The callback functor is called after calling <a class="el" href="classRTC_1_1PortBase.html#acf31878c5912f56c122aaa2310e182de" title="Publish interface information.">publishInterfaces()</a> that is virtual member function of the <a class="el" href="classRTC_1_1PortBase.html" title="Port base class.">PortBase</a> class with an argument of ConnectorProfile type that is same as the argument of <a class="el" href="classRTC_1_1PortBase.html#acf31878c5912f56c122aaa2310e182de" title="Publish interface information.">publishInterfaces()</a> function. Although by using this functor, you can modify the ConnectorProfile published by <a class="el" href="classRTC_1_1PortBase.html#acf31878c5912f56c122aaa2310e182de" title="Publish interface information.">publishInterfaces()</a> function, the modification should be done carefully for fear of causing connection inconsistency.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on_publish</em>&nbsp;</td><td>a pointer to ConnectionCallback's subclasses </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9783d3edef34a7f5c5cef910b4fa33a"></a><!-- doxytag: member="RTC::PortBase::setOnSubscribeInterfaces" ref="ac9783d3edef34a7f5c5cef910b4fa33a" args="(ConnectionCallback *on_subscribe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::setOnSubscribeInterfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>on_subscribe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting callback called on publish interfaces. </p>
<p>This operation sets a functor that is called before subscribing interfaces process when connecting between ports.</p>
<p>Since the ownership of the callback functor object is owned by the caller, it has the responsibility of object destruction.</p>
<p>The callback functor is called before calling <a class="el" href="classRTC_1_1PortBase.html#afce755069836c1ee637784e2a9e5a02b" title="Publish interface information.">subscribeInterfaces()</a> that is virtual member function of the <a class="el" href="classRTC_1_1PortBase.html" title="Port base class.">PortBase</a> class with an argument of ConnectorProfile type that is same as the argument of <a class="el" href="classRTC_1_1PortBase.html#afce755069836c1ee637784e2a9e5a02b" title="Publish interface information.">subscribeInterfaces()</a> function. Although by using this functor, you can modify ConnectorProfile argument for <a class="el" href="classRTC_1_1PortBase.html#afce755069836c1ee637784e2a9e5a02b" title="Publish interface information.">subscribeInterfaces()</a> function, the modification should be done carefully for fear of causing connection inconsistency.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on_subscribe</em>&nbsp;</td><td>a pointer to ConnectionCallback's subclasses </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff023d4b2faa7d161b7c91ef9273a705"></a><!-- doxytag: member="RTC::PortBase::setOnUnsubscribeInterfaces" ref="aff023d4b2faa7d161b7c91ef9273a705" args="(ConnectionCallback *on_subscribe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::setOnUnsubscribeInterfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>on_subscribe</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting callback called on unsubscribe interfaces. </p>
<p>This operation sets a functor that is called before unsubscribing interfaces process when disconnecting between ports.</p>
<p>Since the ownership of the callback functor object is owned by the caller, it has the responsibility of object destruction.</p>
<p>The callback functor is called before calling <a class="el" href="classRTC_1_1PortBase.html#a8a843a387e99d4d4daa6e829eb1db569" title="Disconnect interface connection.">unsubscribeInterfaces()</a> that is virtual member function of the <a class="el" href="classRTC_1_1PortBase.html" title="Port base class.">PortBase</a> class with an argument of ConnectorProfile type that is same as the argument of <a class="el" href="classRTC_1_1PortBase.html#a8a843a387e99d4d4daa6e829eb1db569" title="Disconnect interface connection.">unsubscribeInterfaces()</a> function. Although by using this functor, you can modify ConnectorProfile argument for <a class="el" href="classRTC_1_1PortBase.html#a8a843a387e99d4d4daa6e829eb1db569" title="Disconnect interface connection.">unsubscribeInterfaces()</a> function, the modification should be done carefully for fear of causing connection inconsistency.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on_unsubscribe</em>&nbsp;</td><td>a pointer to ConnectionCallback's subclasses </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1431e933c50b7f31df6446051ca4b3fe"></a><!-- doxytag: member="RTC::PortBase::setOwner" ref="a1431e933c50b7f31df6446051ca4b3fe" args="(RTObject_ptr owner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::setOwner </td>
          <td>(</td>
          <td class="paramtype">RTObject_ptr&nbsp;</td>
          <td class="paramname"> <em>owner</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the owner RTObject of the Port. </p>
<p>This operation sets the owner RTObject of this Port.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owner</em>&nbsp;</td><td>The owner RTObject's reference of this Port </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0fca5f8b8ce5503439f21c7e940227b"></a><!-- doxytag: member="RTC::PortBase::setPortConnectListenerHolder" ref="aa0fca5f8b8ce5503439f21c7e940227b" args="(PortConnectListeners *portconnListeners)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::setPortConnectListenerHolder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1PortConnectListeners.html">PortConnectListeners</a> *&nbsp;</td>
          <td class="paramname"> <em>portconnListeners</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting <a class="el" href="classRTC_1_1PortConnectListener.html" title="PortConnectListener class.">PortConnectListener</a> holder. </p>
<p>This operation sets a functor that is called when connection of this port does lost.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on_connection_lost</em>&nbsp;</td><td>a pointer to ConnectionCallback's subclasses </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a710706ff630c6502e3de6cf5dd302c83"></a><!-- doxytag: member="RTC::PortBase::setPortRef" ref="a710706ff630c6502e3de6cf5dd302c83" args="(PortService_ptr port_ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::setPortRef </td>
          <td>(</td>
          <td class="paramtype">PortService_ptr&nbsp;</td>
          <td class="paramname"> <em>port_ref</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the object reference of this Port. </p>
<p>This operation sets the object reference itself to the Port's PortProfile.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port_ref</em>&nbsp;</td><td>The object reference of this Port. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d8fb06825e17568567786987bd00fbb"></a><!-- doxytag: member="RTC::PortBase::setUUID" ref="a7d8fb06825e17568567786987bd00fbb" args="(ConnectorProfile &amp;connector_profile) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::setUUID </td>
          <td>(</td>
          <td class="paramtype">ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate and set the UUID to the ConnectorProfile. </p>
<p>This operation generates and set UUID to the ConnectorProfile.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>ConnectorProfile to be set connector_id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afce755069836c1ee637784e2a9e5a02b"></a><!-- doxytag: member="RTC::PortBase::subscribeInterfaces" ref="afce755069836c1ee637784e2a9e5a02b" args="(const ConnectorProfile &amp;connector_profile)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode_t RTC::PortBase::subscribeInterfaces </td>
          <td>(</td>
          <td class="paramtype">const ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Publish interface information. </p>
<p>This operation is pure virutal function that would be called at the mid-flow of the <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a> process sequence. In the <a class="el" href="classRTC_1_1PortBase.html#a9bcc3c981a6649f37f3ad7eac31e5766" title="[CORBA interface] Notify the Ports connection">notify_connect()</a>, the following methods would be called in order.</p>
<ul>
<li><a class="el" href="classRTC_1_1PortBase.html#acf31878c5912f56c122aaa2310e182de" title="Publish interface information.">publishInterfaces()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#acd7017c12c99c59c191d1269b40a7423" title="Call notify_connect() of the next Port.">connectNext()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#afce755069836c1ee637784e2a9e5a02b" title="Publish interface information.">subscribeInterfaces()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#aaaa8155f6dd891d0a4b77e6f6c55c97b" title="Append or update the ConnectorProfile list.">updateConnectorProfile()</a></li>
</ul>
<p>In the concrete Port, this method should be overridden. This method processes the given ConnectorProfile argument and if the given parameter is invalid, it would return error code of ReturnCode_t. The given argument ConnectorProfile includes all the interfaces information in it. Usually, subscribeInterafaces() method obtains information of interfaces from ConnectorProfile, and should set it to the interfaces that require them. <br/>
 This operation should create the new connection for the new connector_id, and should update the connection for the existing connection_id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>The connection profile information</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return code of ReturnCode_t type. </dd></dl>

<p>Implemented in <a class="el" href="classRTC_1_1CorbaPort.html#ad9a122cbe2f9892cc9555e805571742e">RTC::CorbaPort</a>, <a class="el" href="classRTC_1_1InPortBase.html#adf648c377e5730a2de6dc48fc47543fb">RTC::InPortBase</a>, and <a class="el" href="classRTC_1_1OutPortBase.html#a76018cbaa5c13fa3363e196c442f5c49">RTC::OutPortBase</a>.</p>

</div>
</div>
<a class="anchor" id="a8a843a387e99d4d4daa6e829eb1db569"></a><!-- doxytag: member="RTC::PortBase::unsubscribeInterfaces" ref="a8a843a387e99d4d4daa6e829eb1db569" args="(const ConnectorProfile &amp;connector_profile)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RTC::PortBase::unsubscribeInterfaces </td>
          <td>(</td>
          <td class="paramtype">const ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect interface connection. </p>
<p>This operation is pure virutal function that would be called at the end of the <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a> process sequence. In the <a class="el" href="classRTC_1_1PortBase.html#ae78bb7882d22bca794bd0faa78452aca" title="[CORBA interface] Notify the Ports disconnection">notify_disconnect()</a>, the following methods would be called in order to disconnect.</p>
<ul>
<li><a class="el" href="classRTC_1_1PortBase.html#a4eeddc35a698e4020e7ba96627dcde3b" title="Call notify_disconnect() of the next Port.">disconnectNext()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#a8a843a387e99d4d4daa6e829eb1db569" title="Disconnect interface connection.">unsubscribeInterfaces()</a></li>
<li><a class="el" href="classRTC_1_1PortBase.html#a3803219dc15de9ebb9bf096a82cfb383" title="Delete the ConnectorProfile.">eraseConnectorProfile()</a> <br/>
 In the concrete Port, this method should be overridden. This method processes the given ConnectorProfile argument and disconnect interface connection.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>The connection profile information </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classRTC_1_1CorbaPort.html#a4776e122a3066d9e3a3e5d1e5da45b98">RTC::CorbaPort</a>, <a class="el" href="classRTC_1_1InPortBase.html#a118932439dce0dc96571b0123615c36e">RTC::InPortBase</a>, and <a class="el" href="classRTC_1_1OutPortBase.html#ad2c373292a41c5f2eb088e7ae124b857">RTC::OutPortBase</a>.</p>

</div>
</div>
<a class="anchor" id="aaaa8155f6dd891d0a4b77e6f6c55c97b"></a><!-- doxytag: member="RTC::PortBase::updateConnectorProfile" ref="aaaa8155f6dd891d0a4b77e6f6c55c97b" args="(const ConnectorProfile &amp;connector_profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::updateConnectorProfile </td>
          <td>(</td>
          <td class="paramtype">const ConnectorProfile &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_profile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append or update the ConnectorProfile list. </p>
<p>This operation appends or updates ConnectorProfile of the Port by the given ConnectorProfile. If the connector_id of the given ConnectorProfile does not exist in the Port's ConnectorProfile list, the given ConnectorProfile would be append to the list. If the same id exists, the list would be updated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connector_profile</em>&nbsp;</td><td>the ConnectorProfile to be appended or updated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9e0697ef8a7138cdf30ab756ecc9242"></a><!-- doxytag: member="RTC::PortBase::updateConnectors" ref="aa9e0697ef8a7138cdf30ab756ecc9242" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PortBase::updateConnectors </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect ports that doesn't exist. </p>
<p>This function detects dead-port, and if dead ports are found in the connection list, disconnects them. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a0c568d0d7ffd5c5dfbf7cdfbd27e22c9"></a><!-- doxytag: member="RTC::PortBase::m_connectionLimit" ref="a0c568d0d7ffd5c5dfbf7cdfbd27e22c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classRTC_1_1PortBase.html#a0c568d0d7ffd5c5dfbf7cdfbd27e22c9">RTC::PortBase::m_connectionLimit</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum number of connections. </p>

</div>
</div>
<a class="anchor" id="acbdf425104a21619d4c887e415e045c8"></a><!-- doxytag: member="RTC::PortBase::m_connectorsMutex" ref="acbdf425104a21619d4c887e415e045c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoil_1_1Mutex.html">coil::Mutex</a> <a class="el" href="classRTC_1_1PortBase.html#acbdf425104a21619d4c887e415e045c8">RTC::PortBase::m_connectorsMutex</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="InPort_8h_source.html#l00276">RTC::InPort&lt; DataType &gt;::isEmpty()</a>, <a class="el" href="InPort_8h_source.html#l00225">RTC::InPort&lt; DataType &gt;::isNew()</a>, <a class="el" href="InPort_8h_source.html#l00378">RTC::InPort&lt; DataType &gt;::read()</a>, and <a class="el" href="OutPort_8h_source.html#l00203">RTC::OutPort&lt; DataType &gt;::write()</a>.</p>

</div>
</div>
<a class="anchor" id="a6add3c9750060e44acaec9e70a78ed92"></a><!-- doxytag: member="RTC::PortBase::m_objref" ref="a6add3c9750060e44acaec9e70a78ed92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTC::PortService_var <a class="el" href="classRTC_1_1PortBase.html#a6add3c9750060e44acaec9e70a78ed92">RTC::PortBase::m_objref</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Object Reference of the Port. </p>

</div>
</div>
<a class="anchor" id="a52852f17f0978a6a639fcf6c8a8a71b6"></a><!-- doxytag: member="RTC::PortBase::m_onConnected" ref="a52852f17f0978a6a639fcf6c8a8a71b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a>* <a class="el" href="classRTC_1_1PortBase.html#a52852f17f0978a6a639fcf6c8a8a71b6">RTC::PortBase::m_onConnected</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback functor objects. </p>
<p>This is a callback object that is called when the connection is completed. </p>

</div>
</div>
<a class="anchor" id="a2d7cfeb11e8bccae7702badef6d384f4"></a><!-- doxytag: member="RTC::PortBase::m_onConnectionLost" ref="a2d7cfeb11e8bccae7702badef6d384f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a>* <a class="el" href="classRTC_1_1PortBase.html#a2d7cfeb11e8bccae7702badef6d384f4">RTC::PortBase::m_onConnectionLost</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback functor objects. </p>
<p>This is a callback object called when the connection of the port does lost. </p>

<p>Referenced by <a class="el" href="OutPort_8h_source.html#l00203">RTC::OutPort&lt; DataType &gt;::write()</a>.</p>

</div>
</div>
<a class="anchor" id="ac1ddf7686081da5a663f9109b7ad740f"></a><!-- doxytag: member="RTC::PortBase::m_onDisconnected" ref="ac1ddf7686081da5a663f9109b7ad740f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a>* <a class="el" href="classRTC_1_1PortBase.html#ac1ddf7686081da5a663f9109b7ad740f">RTC::PortBase::m_onDisconnected</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback functor objects. </p>
<p>This is a callback object that is called in connected release. </p>

</div>
</div>
<a class="anchor" id="a85b7308b6911a14bbd26f62106fa2986"></a><!-- doxytag: member="RTC::PortBase::m_onPublishInterfaces" ref="a85b7308b6911a14bbd26f62106fa2986" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a>* <a class="el" href="classRTC_1_1PortBase.html#a85b7308b6911a14bbd26f62106fa2986">RTC::PortBase::m_onPublishInterfaces</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback functor objects. </p>
<p>This is callback objedct that is called when the interface is opened to the public. </p>

</div>
</div>
<a class="anchor" id="a63ef15306f2d4d66b9570f11d8715057"></a><!-- doxytag: member="RTC::PortBase::m_onSubscribeInterfaces" ref="a63ef15306f2d4d66b9570f11d8715057" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a>* <a class="el" href="classRTC_1_1PortBase.html#a63ef15306f2d4d66b9570f11d8715057">RTC::PortBase::m_onSubscribeInterfaces</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback functor objects. </p>
<p>This is callback objedct that is called when the interface is got. </p>

</div>
</div>
<a class="anchor" id="a34d4ada2f1dfcebec2adc85e5aea484a"></a><!-- doxytag: member="RTC::PortBase::m_onUnsubscribeInterfaces" ref="a34d4ada2f1dfcebec2adc85e5aea484a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTC_1_1ConnectionCallback.html">ConnectionCallback</a>* <a class="el" href="classRTC_1_1PortBase.html#a34d4ada2f1dfcebec2adc85e5aea484a">RTC::PortBase::m_onUnsubscribeInterfaces</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback functor objects. </p>
<p>This is a callback object that is called when the interface is released. </p>

</div>
</div>
<a class="anchor" id="a6f33c6161ecc2b00babcb3a18c7438df"></a><!-- doxytag: member="RTC::PortBase::m_ownerInstanceName" ref="a6f33c6161ecc2b00babcb3a18c7438df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classRTC_1_1PortBase.html#a6f33c6161ecc2b00babcb3a18c7438df">RTC::PortBase::m_ownerInstanceName</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instance name. </p>

</div>
</div>
<a class="anchor" id="a0e9ebbf6f53845b48d087240eeb8656f"></a><!-- doxytag: member="RTC::PortBase::m_portconnListeners" ref="a0e9ebbf6f53845b48d087240eeb8656f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTC_1_1PortConnectListeners.html">PortConnectListeners</a>* <a class="el" href="classRTC_1_1PortBase.html#a0e9ebbf6f53845b48d087240eeb8656f">RTC::PortBase::m_portconnListeners</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classRTC_1_1PortConnectListener.html" title="PortConnectListener class.">PortConnectListener</a> holder. </p>
<p>Holders of <a class="el" href="classRTC_1_1PortConnectListeners.html" title="PortConnectListeners class.">PortConnectListeners</a> </p>

<p>Referenced by <a class="el" href="PortBase_8h_source.html#l02021">onConnected()</a>, <a class="el" href="PortBase_8h_source.html#l01997">onConnectNextport()</a>, <a class="el" href="PortBase_8h_source.html#l02043">onDisconnected()</a>, <a class="el" href="PortBase_8h_source.html#l02032">onDisconnectNextport()</a>, <a class="el" href="PortBase_8h_source.html#l01956">onNotifyConnect()</a>, <a class="el" href="PortBase_8h_source.html#l01966">onNotifyDisconnect()</a>, <a class="el" href="PortBase_8h_source.html#l01985">onPublishInterfaces()</a>, <a class="el" href="PortBase_8h_source.html#l02009">onSubscribeInterfaces()</a>, and <a class="el" href="PortBase_8h_source.html#l01975">onUnsubscribeInterfaces()</a>.</p>

</div>
</div>
<a class="anchor" id="a02b8a89853dc64600f9301a87f50138a"></a><!-- doxytag: member="RTC::PortBase::m_profile" ref="a02b8a89853dc64600f9301a87f50138a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PortProfile <a class="el" href="classRTC_1_1PortBase.html#a02b8a89853dc64600f9301a87f50138a">RTC::PortBase::m_profile</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PortProfile of the Port. </p>

<p>Referenced by <a class="el" href="PortBase_8h_source.html#l01876">addProperty()</a>, and <a class="el" href="PortBase_8h_source.html#l01907">appendProperty()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ee84ba32ff8423c318798dea9814642"></a><!-- doxytag: member="RTC::PortBase::m_profile_mutex" ref="a2ee84ba32ff8423c318798dea9814642" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoil_1_1Mutex.html">coil::Mutex</a> <a class="el" href="classRTC_1_1PortBase.html#a2ee84ba32ff8423c318798dea9814642">RTC::PortBase::m_profile_mutex</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mutex of PortProfile. </p>

</div>
</div>
<a class="anchor" id="ab111ca721c706fe5e93da18705ace90e"></a><!-- doxytag: member="RTC::PortBase::rtclog" ref="ab111ca721c706fe5e93da18705ace90e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRTC_1_1Logger.html">Logger</a> <a class="el" href="classRTC_1_1PortBase.html#ab111ca721c706fe5e93da18705ace90e">RTC::PortBase::rtclog</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classRTC_1_1Logger.html" title="Logger class.">Logger</a> stream. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu May 24 23:25:22 2012 for OpenRTM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
