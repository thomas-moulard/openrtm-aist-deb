<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenRTM: RTC::PublisherFlush Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceRTC.html">RTC</a>::<a class="el" href="classRTC_1_1PublisherFlush.html">PublisherFlush</a>
  </div>
</div>
<div class="contents">
<h1>RTC::PublisherFlush Class Reference</h1><!-- doxytag: class="RTC::PublisherFlush" --><!-- doxytag: inherits="RTC::PublisherBase" -->
<p><a class="el" href="classRTC_1_1PublisherFlush.html" title="PublisherFlush class.">PublisherFlush</a> class.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PublisherFlush_8h_source.html">PublisherFlush.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RTC::PublisherFlush:</div>
<div class="dynsection">
 <div class="center">
  <img src="classRTC_1_1PublisherFlush.png" usemap="#RTC::PublisherFlush_map" alt=""/>
  <map id="RTC::PublisherFlush_map" name="RTC::PublisherFlush_map">
<area href="classRTC_1_1PublisherBase.html" alt="RTC::PublisherBase" shape="rect" coords="0,56,126,80"/>
<area href="classRTC_1_1DataPortStatus.html" alt="RTC::DataPortStatus" shape="rect" coords="0,0,126,24"/>
</map>
 </div>
</div>

<p><a href="classRTC_1_1PublisherFlush-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcoil_1_1Mutex.html">coil::Mutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a0b126166c45497fbec4a9e9a9f788efe">Mutex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcoil_1_1Condition.html">coil::Condition</a>&lt; <a class="el" href="classcoil_1_1Mutex.html">Mutex</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a09b7bebb83f30e55d3cf46ceb9533d6a">Condition</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcoil_1_1Guard.html">coil::Guard</a>&lt; <a class="el" href="classcoil_1_1Mutex.html">coil::Mutex</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#aa7e6e2ab96bed2a30c98a83b434aac78">Guard</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DATAPORTSTATUS_ENUM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a488eda00a5d7f0522825470d9f1ec6c2">PublisherFlush</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a488eda00a5d7f0522825470d9f1ec6c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a2c95ba8d90b64c3b92dd58456af629ff">~PublisherFlush</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a2c95ba8d90b64c3b92dd58456af629ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a89931a404b169f942de90e0493d39aa9">init</a> (<a class="el" href="classcoil_1_1Properties.html">coil::Properties</a> &amp;prop)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialization  <a href="#a89931a404b169f942de90e0493d39aa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#afb12f77e4557f2419f6a61b031f4798f">setConsumer</a> (<a class="el" href="classRTC_1_1InPortConsumer.html">InPortConsumer</a> *consumer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> consumer.  <a href="#afb12f77e4557f2419f6a61b031f4798f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a2997f6f2d80fb4e278113740a6f628dd">setBuffer</a> (<a class="el" href="classRTC_1_1BufferBase.html">CdrBufferBase</a> *buffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting buffer pointer.  <a href="#a2997f6f2d80fb4e278113740a6f628dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ::<a class="el" href="classRTC_1_1DataPortStatus.html#ac47c3e85f39e51eb55230337c0efc64f">RTC::DataPortStatus::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a6297071d496c75c969b700832f32f595">setListener</a> (<a class="el" href="classRTC_1_1ConnectorInfo.html">ConnectorInfo</a> &amp;profile, <a class="el" href="classRTC_1_1ConnectorListeners.html">RTC::ConnectorListeners</a> *listeners)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the listener.  <a href="#a6297071d496c75c969b700832f32f595"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#ad84eb745390b45d7c23730409a017787">write</a> (const cdrMemoryStream &amp;data, unsigned long sec, unsigned long usec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data.  <a href="#ad84eb745390b45d7c23730409a017787"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a8e6f548411b5956b73d8c3592f15da2a">isActive</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If publisher is active state.  <a href="#a8e6f548411b5956b73d8c3592f15da2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#ae9797c90a29dc02d477b4ec9d9fbad1c">activate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">activation  <a href="#ae9797c90a29dc02d477b4ec9d9fbad1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ReturnCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a5d288cbf168685dc2c85578b0f4485c1">deactivate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">deactivation  <a href="#a5d288cbf168685dc2c85578b0f4485c1"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a88f77e8b488b3025235af926587c89a5">onSend</a> (const cdrMemoryStream &amp;data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify an ON_SEND event to listners.  <a href="#a88f77e8b488b3025235af926587c89a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a03ce9f919e40c6a3b21c37d944310943">onReceived</a> (const cdrMemoryStream &amp;data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify an ON_RECEIVED event to listeners.  <a href="#a03ce9f919e40c6a3b21c37d944310943"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#adc8ff57907fc7a0c6ca4f625b6a7c2f2">onReceiverFull</a> (const cdrMemoryStream &amp;data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify an ON_RECEIVER_FULL event to listeners.  <a href="#adc8ff57907fc7a0c6ca4f625b6a7c2f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a2b568af9c0275c23cf9b5b1ec12ca392">onReceiverTimeout</a> (const cdrMemoryStream &amp;data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify an ON_RECEIVER_TIMEOUT event to listeners.  <a href="#a2b568af9c0275c23cf9b5b1ec12ca392"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRTC_1_1PublisherFlush.html#a178e585fee9caa9eca408390870d0b93">onReceiverError</a> (const cdrMemoryStream &amp;data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify an ON_RECEIVER_ERROR event to listeners.  <a href="#a178e585fee9caa9eca408390870d0b93"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classRTC_1_1PublisherFlush.html" title="PublisherFlush class.">PublisherFlush</a> class. </p>
<p>This is a Publisher class of Flush type. This class sends unsend data that has been stored in the buffer. This executes <a class="el" href="classConsumer.html" title="Placeholder template class to hold remote object reference.">Consumer</a> that waits for the data send timing in the same thread as its send side. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a09b7bebb83f30e55d3cf46ceb9533d6a"></a><!-- doxytag: member="RTC::PublisherFlush::Condition" ref="a09b7bebb83f30e55d3cf46ceb9533d6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcoil_1_1Condition.html">coil::Condition</a>&lt;<a class="el" href="classcoil_1_1Mutex.html">Mutex</a>&gt; <a class="el" href="classcoil_1_1Condition.html">RTC::PublisherFlush::Condition</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7e6e2ab96bed2a30c98a83b434aac78"></a><!-- doxytag: member="RTC::PublisherFlush::Guard" ref="aa7e6e2ab96bed2a30c98a83b434aac78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcoil_1_1Guard.html">coil::Guard</a>&lt;<a class="el" href="classcoil_1_1Mutex.html">coil::Mutex</a>&gt; <a class="el" href="classcoil_1_1Guard.html">RTC::PublisherFlush::Guard</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b126166c45497fbec4a9e9a9f788efe"></a><!-- doxytag: member="RTC::PublisherFlush::Mutex" ref="a0b126166c45497fbec4a9e9a9f788efe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcoil_1_1Mutex.html">coil::Mutex</a> <a class="el" href="classcoil_1_1Mutex.html">RTC::PublisherFlush::Mutex</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a488eda00a5d7f0522825470d9f1ec6c2"></a><!-- doxytag: member="RTC::PublisherFlush::PublisherFlush" ref="a488eda00a5d7f0522825470d9f1ec6c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DATAPORTSTATUS_ENUM RTC::PublisherFlush::PublisherFlush </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>Consrtuctor. </p>

</div>
</div>
<a class="anchor" id="a2c95ba8d90b64c3b92dd58456af629ff"></a><!-- doxytag: member="RTC::PublisherFlush::~PublisherFlush" ref="a2c95ba8d90b64c3b92dd58456af629ff" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual RTC::PublisherFlush::~PublisherFlush </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Destructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae9797c90a29dc02d477b4ec9d9fbad1c"></a><!-- doxytag: member="RTC::PublisherFlush::activate" ref="ae9797c90a29dc02d477b4ec9d9fbad1c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode RTC::PublisherFlush::activate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>activation </p>
<p>This function activates the publisher. By calling this function, this publisher starts the thread that pushes data to <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a>. If precondition such as initialization process and so on is not met, the error code PRECONDITION_NOT_MET is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>PORT_OK normal return PRECONDITION_NOT_MET precondition is not met </dd></dl>

<p>Implements <a class="el" href="classRTC_1_1PublisherBase.html#a4f0e0ca91e07a25481ffa83ef027feb6">RTC::PublisherBase</a>.</p>

</div>
</div>
<a class="anchor" id="a5d288cbf168685dc2c85578b0f4485c1"></a><!-- doxytag: member="RTC::PublisherFlush::deactivate" ref="a5d288cbf168685dc2c85578b0f4485c1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode RTC::PublisherFlush::deactivate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>deactivation </p>
<p>This function deactivates the publisher. By calling this function, this publisher stops the thread that pushes data to <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a>. If precondition such as initialization process and so on is not met, the error code PRECONDITION_NOT_MET is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>PORT_OK normal return PRECONDITION_NOT_MET precondition is not met </dd></dl>

<p>Implements <a class="el" href="classRTC_1_1PublisherBase.html#ace68807ed92a38af8ca49ece25db0d8a">RTC::PublisherBase</a>.</p>

</div>
</div>
<a class="anchor" id="a89931a404b169f942de90e0493d39aa9"></a><!-- doxytag: member="RTC::PublisherFlush::init" ref="a89931a404b169f942de90e0493d39aa9" args="(coil::Properties &amp;prop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode RTC::PublisherFlush::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoil_1_1Properties.html">coil::Properties</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prop</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialization </p>
<p>This function have to be called before using this class object. However, this <a class="el" href="classRTC_1_1PublisherFlush.html" title="PublisherFlush class.">PublisherFlush</a> class has no parameters to be initialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property</em>&nbsp;</td><td>Property objects that includes the control information of this Publisher </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ReturnCode PORT_OK normal return INVALID_ARGS Properties with invalid values. </dd></dl>

<p>Implements <a class="el" href="classRTC_1_1PublisherBase.html#a9915af3afab216e2b39fa8702b54b0b7">RTC::PublisherBase</a>.</p>

</div>
</div>
<a class="anchor" id="a8e6f548411b5956b73d8c3592f15da2a"></a><!-- doxytag: member="RTC::PublisherFlush::isActive" ref="a8e6f548411b5956b73d8c3592f15da2a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RTC::PublisherFlush::isActive </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If publisher is active state. </p>
<p>A Publisher can be activated/deactivated synchronized with the data port. The active state and the non-active state are made transition by the "activate()" and the "deactivate()" functions respectively. This function confirms if the publisher is in active state.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Result of state confirmation (Active state:true, Inactive state:false) </dd></dl>

<p>Implements <a class="el" href="classRTC_1_1PublisherBase.html#aed0e118b4a1bda091ba38066cc8e4c7b">RTC::PublisherBase</a>.</p>

</div>
</div>
<a class="anchor" id="a03ce9f919e40c6a3b21c37d944310943"></a><!-- doxytag: member="RTC::PublisherFlush::onReceived" ref="a03ce9f919e40c6a3b21c37d944310943" args="(const cdrMemoryStream &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PublisherFlush::onReceived </td>
          <td>(</td>
          <td class="paramtype">const cdrMemoryStream &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify an ON_RECEIVED event to listeners. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>cdrMemoryStream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ConnectorListener_8h_source.html#l00075">RTC::ON_RECEIVED</a>.</p>

</div>
</div>
<a class="anchor" id="a178e585fee9caa9eca408390870d0b93"></a><!-- doxytag: member="RTC::PublisherFlush::onReceiverError" ref="a178e585fee9caa9eca408390870d0b93" args="(const cdrMemoryStream &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PublisherFlush::onReceiverError </td>
          <td>(</td>
          <td class="paramtype">const cdrMemoryStream &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify an ON_RECEIVER_ERROR event to listeners. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>cdrMemoryStream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ConnectorListener_8h_source.html#l00078">RTC::ON_RECEIVER_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="adc8ff57907fc7a0c6ca4f625b6a7c2f2"></a><!-- doxytag: member="RTC::PublisherFlush::onReceiverFull" ref="adc8ff57907fc7a0c6ca4f625b6a7c2f2" args="(const cdrMemoryStream &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PublisherFlush::onReceiverFull </td>
          <td>(</td>
          <td class="paramtype">const cdrMemoryStream &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify an ON_RECEIVER_FULL event to listeners. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>cdrMemoryStream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ConnectorListener_8h_source.html#l00076">RTC::ON_RECEIVER_FULL</a>.</p>

</div>
</div>
<a class="anchor" id="a2b568af9c0275c23cf9b5b1ec12ca392"></a><!-- doxytag: member="RTC::PublisherFlush::onReceiverTimeout" ref="a2b568af9c0275c23cf9b5b1ec12ca392" args="(const cdrMemoryStream &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PublisherFlush::onReceiverTimeout </td>
          <td>(</td>
          <td class="paramtype">const cdrMemoryStream &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify an ON_RECEIVER_TIMEOUT event to listeners. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>cdrMemoryStream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ConnectorListener_8h_source.html#l00077">RTC::ON_RECEIVER_TIMEOUT</a>.</p>

</div>
</div>
<a class="anchor" id="a88f77e8b488b3025235af926587c89a5"></a><!-- doxytag: member="RTC::PublisherFlush::onSend" ref="a88f77e8b488b3025235af926587c89a5" args="(const cdrMemoryStream &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RTC::PublisherFlush::onSend </td>
          <td>(</td>
          <td class="paramtype">const cdrMemoryStream &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify an ON_SEND event to listners. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>cdrMemoryStream </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ConnectorListener_8h_source.html#l00074">RTC::ON_SEND</a>.</p>

</div>
</div>
<a class="anchor" id="a2997f6f2d80fb4e278113740a6f628dd"></a><!-- doxytag: member="RTC::PublisherFlush::setBuffer" ref="a2997f6f2d80fb4e278113740a6f628dd" args="(CdrBufferBase *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode RTC::PublisherFlush::setBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1BufferBase.html">CdrBufferBase</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setting buffer pointer. </p>
<p>Since <a class="el" href="classRTC_1_1PublisherFlush.html" title="PublisherFlush class.">PublisherFlush</a> does not use any buffers, This function always returns PORT_OK.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>CDR buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PORT_OK </dd></dl>

</div>
</div>
<a class="anchor" id="afb12f77e4557f2419f6a61b031f4798f"></a><!-- doxytag: member="RTC::PublisherFlush::setConsumer" ref="afb12f77e4557f2419f6a61b031f4798f" args="(InPortConsumer *consumer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode RTC::PublisherFlush::setConsumer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1InPortConsumer.html">InPortConsumer</a> *&nbsp;</td>
          <td class="paramname"> <em>consumer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store <a class="el" href="classRTC_1_1InPort.html" title="InPort template class.">InPort</a> consumer. </p>
<p>This operation sets a consumer that is associated with this object. If the consumer object is NULL, INVALID_ARGS will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>consumer</em>&nbsp;</td><td>A pointer to a consumer object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ReturnCode PORT_OK normal return INVALID_ARGS given argument has invalid value </dd></dl>

<p>Implements <a class="el" href="classRTC_1_1PublisherBase.html#a7ff8bf60fa9d713402572404b3dc922c">RTC::PublisherBase</a>.</p>

</div>
</div>
<a class="anchor" id="a6297071d496c75c969b700832f32f595"></a><!-- doxytag: member="RTC::PublisherFlush::setListener" ref="a6297071d496c75c969b700832f32f595" args="(ConnectorInfo &amp;profile, RTC::ConnectorListeners *listeners)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ::<a class="el" href="classRTC_1_1DataPortStatus.html#ac47c3e85f39e51eb55230337c0efc64f">RTC::DataPortStatus::Enum</a> RTC::PublisherFlush::setListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRTC_1_1ConnectorInfo.html">ConnectorInfo</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRTC_1_1ConnectorListeners.html">RTC::ConnectorListeners</a> *&nbsp;</td>
          <td class="paramname"> <em>listeners</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the listener. </p>
<p>This function sets <a class="el" href="classRTC_1_1ConnectorListeners.html" title="ConnectorListeners class.">ConnectorListeners</a> listener object to the Publisher. By setting <a class="el" href="classRTC_1_1ConnectorListeners.html" title="ConnectorListeners class.">ConnectorListeners</a> containing various listeners objects, these listeners are called at the time of reading and writing of a buffer, and transmission of data etc. Since the ownership of the <a class="el" href="classRTC_1_1ConnectorListeners.html" title="ConnectorListeners class.">ConnectorListeners</a> object is owned by Port or RTObject, the Publisher never deletes the <a class="el" href="classRTC_1_1ConnectorListeners.html" title="ConnectorListeners class.">ConnectorListeners</a> object. If the given ConnectorListeners' pointer is NULL, this function returns INVALID_ARGS.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td><a class="el" href="classRTC_1_1ConnectorInfo.html">ConnectorInfo</a> that is localized object of ConnectorProfile </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>listeners</em>&nbsp;</td><td><a class="el" href="classRTC_1_1ConnectorListeners.html" title="ConnectorListeners class.">ConnectorListeners</a> that holds various listeners </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PORT_OK Normal return INVALID_ARGS Invalid arguments </dd></dl>

<p>Implements <a class="el" href="classRTC_1_1PublisherBase.html#a9d12db1358f8b70a5ee761d905170bc2">RTC::PublisherBase</a>.</p>

</div>
</div>
<a class="anchor" id="ad84eb745390b45d7c23730409a017787"></a><!-- doxytag: member="RTC::PublisherFlush::write" ref="ad84eb745390b45d7c23730409a017787" args="(const cdrMemoryStream &amp;data, unsigned long sec, unsigned long usec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReturnCode RTC::PublisherFlush::write </td>
          <td>(</td>
          <td class="paramtype">const cdrMemoryStream &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>usec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data. </p>
<p>This function writes data into the consumer associated with this Publisher. If this function is called without initializing correctly such as a consumer, listeners, etc., error code PRECONDITION_NOT_MET will be returned and no operation of the writing to the consumer etc. will be performed.</p>
<p>When publisher writes data to the buffer, if the consumer returns full-status, returns error, is returned with timeout, error codes BUFFER_FULL, BUFFER_ERROR and BUFFER_TIMEOUT will be returned respectively.</p>
<p>In other cases, PROT_ERROR will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Data to be wrote to the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sec</em>&nbsp;</td><td>Timeout time in unit seconds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nsec</em>&nbsp;</td><td>Timeout time in unit nano-seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PORT_OK Normal return PRECONDITION_NO_MET Precondition does not met. A consumer, a buffer, listenes are not set properly. SEND_FULL Data was sent but full-status returned SEND_TIMEOUT Data was sent but timeout occurred CONNECTION_LOST detected that the connection has been lost </dd></dl>

<p>Implements <a class="el" href="classRTC_1_1PublisherBase.html#abd693b65ffe07276683facfd710be537">RTC::PublisherBase</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu May 24 23:25:23 2012 for OpenRTM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
