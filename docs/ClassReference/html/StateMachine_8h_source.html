<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenRTM: StateMachine.h ソースファイル</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>メインページ</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li class="current"><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>ファイル一覧</span></a></li>
      <li><a href="globals.html"><span>ファイルメンバ</span></a></li>
    </ul>
  </div>
<h1>StateMachine.h</h1><a href="StateMachine_8h.html">説明を見る。</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// -*- C++ -*-</span>
<a name="l00019"></a>00019 <span class="comment"></span><span class="preprocessor">#ifndef RTC_STATEMACHINE_H</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#define RTC_STATEMACHINE_H</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;<a class="code" href="RTC_8h.html" title="RTComponent header.">rtm/RTC.h</a>&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;<a class="code" href="Mutex_8h.html">coil/Mutex.h</a>&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="Guard_8h.html" title="Guard template class.">coil/Guard.h</a>&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="keyword">namespace </span>RTC_Utils
<a name="l00027"></a>00027 {
<a name="l00054"></a>00054   <span class="keyword">template</span> &lt;<span class="keyword">class</span> State&gt;
<a name="l00055"></a><a class="code" href="structRTC__Utils_1_1StateHolder.html">00055</a>   <span class="keyword">struct </span><a class="code" href="structRTC__Utils_1_1StateHolder.html" title="状態保持用クラス">StateHolder</a>
<a name="l00056"></a>00056   {
<a name="l00057"></a><a class="code" href="structRTC__Utils_1_1StateHolder.html#a6d8c823054382ec53cf68d84b57e8376">00057</a>     State <a class="code" href="structRTC__Utils_1_1StateHolder.html#a6d8c823054382ec53cf68d84b57e8376">curr</a>;
<a name="l00058"></a><a class="code" href="structRTC__Utils_1_1StateHolder.html#a8e1e247158f889059ba84d6428a4fd35">00058</a>     State <a class="code" href="structRTC__Utils_1_1StateHolder.html#a8e1e247158f889059ba84d6428a4fd35">prev</a>;
<a name="l00059"></a><a class="code" href="structRTC__Utils_1_1StateHolder.html#af7c8270e02be5f1575d4982115149713">00059</a>     State <a class="code" href="structRTC__Utils_1_1StateHolder.html#af7c8270e02be5f1575d4982115149713">next</a>;
<a name="l00060"></a>00060   };
<a name="l00061"></a>00061   
<a name="l00258"></a>00258   <span class="keyword">template</span> &lt;<span class="keyword">class </span>State,
<a name="l00259"></a>00259             <span class="keyword">class </span>Listener,
<a name="l00260"></a>00260             <span class="keyword">class </span>States = <a class="code" href="structRTC__Utils_1_1StateHolder.html" title="状態保持用クラス">StateHolder&lt;State&gt;</a>, 
<a name="l00261"></a>00261             <span class="keyword">class </span>Callback = void (Listener::*)(<span class="keyword">const</span> States&amp; states)
<a name="l00262"></a>00262             &gt;
<a name="l00263"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html">00263</a>   <span class="keyword">class</span> <a class="code" href="classRTC__Utils_1_1StateMachine.html" title="状態マシンクラス">StateMachine</a>
<a name="l00264"></a>00264   {
<a name="l00265"></a>00265     <span class="keyword">typedef</span> <a class="code" href="classcoil_1_1Mutex.html" title="Mutex クラス.">coil::Mutex</a> <a class="code" href="classcoil_1_1Mutex.html" title="Mutex クラス.">Mutex</a>;
<a name="l00266"></a>00266     <span class="keyword">typedef</span> <a class="code" href="classcoil_1_1Guard.html" title="Guard テンプレートクラス.">coil::Guard&lt;Mutex&gt;</a> <a class="code" href="classcoil_1_1Guard.html" title="Guard テンプレートクラス.">Guard</a>;
<a name="l00267"></a>00267   <span class="keyword">public</span>:
<a name="l00285"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#acca3c5b3e35ae468bde803fd0975f074">00285</a>     <a class="code" href="classRTC__Utils_1_1StateMachine.html" title="状態マシンクラス">StateMachine</a>(<span class="keywordtype">int</span> num_of_state)
<a name="l00286"></a>00286       : m_num(num_of_state),
<a name="l00287"></a>00287         m_entry (new Callback[m_num]),
<a name="l00288"></a>00288         m_predo (new Callback[m_num]),
<a name="l00289"></a>00289         m_do    (new Callback[m_num]),
<a name="l00290"></a>00290         m_postdo(new Callback[m_num]),
<a name="l00291"></a>00291         m_exit  (new Callback[m_num])
<a name="l00292"></a>00292     {
<a name="l00293"></a>00293       setNullFunc(m_entry,  NULL);
<a name="l00294"></a>00294       setNullFunc(m_do,     NULL);
<a name="l00295"></a>00295       setNullFunc(m_exit,   NULL);
<a name="l00296"></a>00296       setNullFunc(m_predo,  NULL);
<a name="l00297"></a>00297       setNullFunc(m_postdo, NULL);
<a name="l00298"></a>00298       m_transit = NULL;
<a name="l00299"></a>00299     };
<a name="l00300"></a>00300     
<a name="l00301"></a>00301 
<a name="l00302"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a26c9f468d0188e47d891b984f8cd761d">00302</a>     <span class="keyword">virtual</span> ~<a class="code" href="classRTC__Utils_1_1StateMachine.html" title="状態マシンクラス">StateMachine</a>()
<a name="l00303"></a>00303     {
<a name="l00304"></a>00304       <span class="keyword">delete</span> [] m_entry;
<a name="l00305"></a>00305       <span class="keyword">delete</span> [] m_predo;
<a name="l00306"></a>00306       <span class="keyword">delete</span> [] m_do;
<a name="l00307"></a>00307       <span class="keyword">delete</span> [] m_postdo;
<a name="l00308"></a>00308       <span class="keyword">delete</span> [] m_exit;
<a name="l00309"></a>00309     };
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 
<a name="l00329"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a0d232546cd076ffbb0860a612e582416">00329</a>     <span class="keywordtype">void</span> setNOP(Callback call_back)
<a name="l00330"></a>00330     {
<a name="l00331"></a>00331       setNullFunc(m_entry,  call_back);
<a name="l00332"></a>00332       setNullFunc(m_do,     call_back);
<a name="l00333"></a>00333       setNullFunc(m_exit,   call_back);
<a name="l00334"></a>00334       setNullFunc(m_predo,  call_back);
<a name="l00335"></a>00335       setNullFunc(m_postdo, call_back);
<a name="l00336"></a>00336       m_transit = call_back;
<a name="l00337"></a>00337     }
<a name="l00338"></a>00338     
<a name="l00356"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#afa4701917d4d6ec2a70f78397519f1f9">00356</a>     <span class="keywordtype">void</span> setListener(Listener* listener)
<a name="l00357"></a>00357     {
<a name="l00358"></a>00358       m_listener = listener;
<a name="l00359"></a>00359     }
<a name="l00360"></a>00360     
<a name="l00385"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a611cd79fa4c9257159de08011e7e6509">00385</a>     <span class="keywordtype">bool</span> setEntryAction(State state, Callback call_back)
<a name="l00386"></a>00386     {
<a name="l00387"></a>00387       m_entry[state] = call_back;
<a name="l00388"></a>00388       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00389"></a>00389     }
<a name="l00390"></a>00390     
<a name="l00414"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a7bdcc53df08ccb0fa7fb31472613b2fe">00414</a>     <span class="keywordtype">bool</span> setPreDoAction(State state, Callback call_back)
<a name="l00415"></a>00415     {
<a name="l00416"></a>00416       m_predo[state] = call_back;
<a name="l00417"></a>00417       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00418"></a>00418     }
<a name="l00419"></a>00419     
<a name="l00443"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a40da53fd17393b10e4b89b9a63ba1332">00443</a>     <span class="keywordtype">bool</span> setDoAction(State state, Callback call_back)
<a name="l00444"></a>00444     {
<a name="l00445"></a>00445       m_do[state] = call_back;
<a name="l00446"></a>00446       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00447"></a>00447     }
<a name="l00448"></a>00448     
<a name="l00472"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#aad4ee723ecbd2f5c97b358336574c26c">00472</a>     <span class="keywordtype">bool</span> setPostDoAction(State state, Callback call_back)
<a name="l00473"></a>00473     {
<a name="l00474"></a>00474       m_postdo[state] = call_back;
<a name="l00475"></a>00475       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00476"></a>00476     }
<a name="l00477"></a>00477     
<a name="l00501"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#ac308579215117b100ba31c38c31d580a">00501</a>     <span class="keywordtype">bool</span> setExitAction(State state, Callback call_back)
<a name="l00502"></a>00502     {
<a name="l00503"></a>00503       m_exit[state] = call_back;
<a name="l00504"></a>00504       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00505"></a>00505     }
<a name="l00506"></a>00506     
<a name="l00530"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a1b18262bc0c7fa8cae25dffd567a0806">00530</a>     <span class="keywordtype">bool</span> setTransitionAction(Callback call_back)
<a name="l00531"></a>00531     {
<a name="l00532"></a>00532       m_transit = call_back;
<a name="l00533"></a>00533       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535     
<a name="l00553"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a5501ddabd4b93f4e7043708e2de26781">00553</a>     <span class="keywordtype">void</span> setStartState(States states)
<a name="l00554"></a>00554     {
<a name="l00555"></a>00555       m_states.curr = states.curr;
<a name="l00556"></a>00556       m_states.prev = states.prev;
<a name="l00557"></a>00557       m_states.next = states.next;
<a name="l00558"></a>00558     }
<a name="l00559"></a>00559     
<a name="l00580"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#af665f3b667caa54e29dc59a6d5b16d4c">00580</a>     States getStates()
<a name="l00581"></a>00581     {
<a name="l00582"></a>00582       Guard guard(m_mutex);
<a name="l00583"></a>00583       <span class="keywordflow">return</span> m_states;
<a name="l00584"></a>00584     }
<a name="l00585"></a>00585     
<a name="l00603"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a1a768beb5bc5ec5a0e828d0e006d8003">00603</a>     State getState()
<a name="l00604"></a>00604     {
<a name="l00605"></a>00605       Guard guard(m_mutex);
<a name="l00606"></a>00606       <span class="keywordflow">return</span> m_states.curr;
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608     
<a name="l00630"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a6338403cf745c61423e310a8b481b9df">00630</a>     <span class="keywordtype">bool</span> isIn(State state)
<a name="l00631"></a>00631     {
<a name="l00632"></a>00632       Guard guard(m_mutex);
<a name="l00633"></a>00633       <span class="keywordflow">return</span> m_states.curr == state ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00634"></a>00634     }
<a name="l00635"></a>00635     
<a name="l00662"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a43b923b77e7e4d3562a83880c488197d">00662</a>     <span class="keywordtype">void</span> goTo(State state)
<a name="l00663"></a>00663     {
<a name="l00664"></a>00664       Guard guard(m_mutex);
<a name="l00665"></a>00665       m_states.next = state;
<a name="l00666"></a>00666       <span class="keywordflow">if</span> (m_states.curr == state)
<a name="l00667"></a>00667         {
<a name="l00668"></a>00668           m_selftrans  = <span class="keyword">true</span>;
<a name="l00669"></a>00669         }
<a name="l00670"></a>00670     }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672     
<a name="l00689"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#af979deaf6160e247a6a6e3027f31c83b">00689</a>     <span class="keywordtype">void</span> worker()
<a name="l00690"></a>00690     {
<a name="l00691"></a>00691       States state;
<a name="l00692"></a>00692       
<a name="l00693"></a>00693       sync(state);
<a name="l00694"></a>00694       
<a name="l00695"></a>00695       <span class="keywordflow">if</span> (state.curr == state.next)
<a name="l00696"></a>00696         {
<a name="l00697"></a>00697           <span class="comment">// pre-do</span>
<a name="l00698"></a>00698           <span class="keywordflow">if</span> (m_predo[state.curr] != NULL)
<a name="l00699"></a>00699             (m_listener-&gt;*m_predo [state.curr])(state);
<a name="l00700"></a>00700           
<a name="l00701"></a>00701           <span class="keywordflow">if</span> (need_trans()) <span class="keywordflow">return</span>;
<a name="l00702"></a>00702           
<a name="l00703"></a>00703           <span class="comment">// do</span>
<a name="l00704"></a>00704           <span class="keywordflow">if</span> (m_do[state.curr] != NULL)
<a name="l00705"></a>00705             (m_listener-&gt;*m_do    [state.curr])(state);
<a name="l00706"></a>00706           
<a name="l00707"></a>00707           <span class="keywordflow">if</span> (need_trans()) <span class="keywordflow">return</span>;
<a name="l00708"></a>00708           
<a name="l00709"></a>00709           <span class="comment">// post-do</span>
<a name="l00710"></a>00710           <span class="keywordflow">if</span> (m_postdo[state.curr] != NULL)
<a name="l00711"></a>00711             (m_listener-&gt;*m_postdo[state.curr])(state);
<a name="l00712"></a>00712         }
<a name="l00713"></a>00713       <span class="keywordflow">else</span>
<a name="l00714"></a>00714         {
<a name="l00715"></a>00715           <span class="keywordflow">if</span> (m_exit[state.curr] != NULL)
<a name="l00716"></a>00716             (m_listener-&gt;*m_exit[state.curr])(state);
<a name="l00717"></a>00717           
<a name="l00718"></a>00718           sync(state);
<a name="l00719"></a>00719           
<a name="l00720"></a>00720           <span class="keywordflow">if</span> (state.curr != state.next)
<a name="l00721"></a>00721             {
<a name="l00722"></a>00722               state.curr = state.next;
<a name="l00723"></a>00723               <span class="keywordflow">if</span>(m_entry[state.curr] != NULL)
<a name="l00724"></a>00724                 (m_listener-&gt;*m_entry[state.curr])(state);
<a name="l00725"></a>00725               update_curr(state.curr);
<a name="l00726"></a>00726             }
<a name="l00727"></a>00727         }
<a name="l00728"></a>00728     }
<a name="l00729"></a>00729     
<a name="l00730"></a>00730   <span class="keyword">protected</span>:
<a name="l00750"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a99b23364ce99c4473f3a149383e7230f">00750</a>     <span class="keywordtype">void</span> setNullFunc(Callback* s, Callback nullfunc)
<a name="l00751"></a>00751     {
<a name="l00752"></a>00752       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_num; ++i) s[i] = nullfunc;
<a name="l00753"></a>00753     }
<a name="l00754"></a>00754     
<a name="l00762"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a2503583562749e18c43ca48c6066d9f4">00762</a>     <span class="keywordtype">int</span> m_num;
<a name="l00763"></a>00763     
<a name="l00771"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a25f2e293e773fe5c4ffdd49fb343f734">00771</a>     Listener* m_listener;
<a name="l00772"></a>00772     
<a name="l00780"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a728fe8f596c77e326bc356b274144bb5">00780</a>     Callback* m_entry;
<a name="l00781"></a>00781     
<a name="l00789"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a687b8b8abab11fb696555fa861240f30">00789</a>     Callback* m_predo;
<a name="l00790"></a>00790     
<a name="l00798"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a86145d8ddee737f186fe019dc84de243">00798</a>     Callback* m_do;
<a name="l00799"></a>00799     
<a name="l00807"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#ac90335d93cc0c173335b130dd91a33e4">00807</a>     Callback* m_postdo;
<a name="l00808"></a>00808     
<a name="l00816"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a75fb6776bd228a8005eda56e49a33373">00816</a>     Callback* m_exit;
<a name="l00817"></a>00817     
<a name="l00825"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#aa292b9b27cf14ea9b82b2ad8b8ddc49d">00825</a>     Callback  m_transit;
<a name="l00826"></a>00826     
<a name="l00834"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#a29e2692dc448060388da12e0a029cfad">00834</a>     States m_states;
<a name="l00835"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#aa02af266af8b8e0abf6609abede2a323">00835</a>     <span class="keywordtype">bool</span> m_selftrans;
<a name="l00836"></a><a class="code" href="classRTC__Utils_1_1StateMachine.html#aedd1306b007958b49a248d07578214b3">00836</a>     Mutex m_mutex;
<a name="l00837"></a>00837     
<a name="l00838"></a>00838   <span class="keyword">private</span>:
<a name="l00839"></a>00839     <span class="keyword">inline</span> <span class="keywordtype">void</span> sync(States&amp; st)
<a name="l00840"></a>00840     {
<a name="l00841"></a>00841       Guard guard(m_mutex);
<a name="l00842"></a>00842       st = m_states;
<a name="l00843"></a>00843     }
<a name="l00844"></a>00844     
<a name="l00845"></a>00845     <span class="keyword">inline</span> <span class="keywordtype">bool</span> need_trans()
<a name="l00846"></a>00846     {
<a name="l00847"></a>00847       Guard guard(m_mutex);
<a name="l00848"></a>00848       <span class="keywordflow">return</span> (m_states.curr != m_states.next);
<a name="l00849"></a>00849     }
<a name="l00850"></a>00850     
<a name="l00851"></a>00851     <span class="keyword">inline</span> <span class="keywordtype">void</span> update_curr(<span class="keyword">const</span> State curr)
<a name="l00852"></a>00852     {
<a name="l00853"></a>00853       Guard guard(m_mutex);
<a name="l00854"></a>00854       m_states.curr = curr;
<a name="l00855"></a>00855     }
<a name="l00856"></a>00856   };
<a name="l00857"></a>00857 }; <span class="comment">// namespace RTC_Utils</span>
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 <span class="preprocessor">#endif // RTC_STATEMACHINE_H</span>
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>OpenRTMに対してThu May 24 23:25:18 2012に生成されました。&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
